<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tirage au sort â€” Ã‰tape 5</title>
  <link rel="stylesheet" href="../assets/css/main.css?v=20260222" />
</head>
<body>

<header class="topbar">
  <div class="container">
    <div class="topbar-row">
      <div class="brand-logo">
        <img src="../assets/img/logo-suzini.png" alt="Logo Suzini">
      </div>

      <h1 class="brand-title">
        Ã‰tape 5 â€” TEST<br>
        <span style="opacity:.95;font-weight:800;">Tirage au sort ğŸ²</span>
      </h1>

      <div class="brand-logo">
        <img src="../assets/img/logo-challenge.png" alt="Logo Challenge">
      </div>
    </div>

    <nav class="nav">
      <a href="../index.html">Accueil</a>
      <a href="programmation.html">Programmation</a>
      <a href="equipes.html">Ã‰quipes</a>
      <a href="inscriptions.html">Inscriptions</a>
      <a href="repas.html">Repas</a>
      <a href="tirage.html" aria-current="page">Tirage au sort</a>
    </nav>
  </div>
</header>

<main class="container">

  <section class="card">
    <h2 style="margin:0 0 10px;">ğŸ² Tirage au sort</h2>
    <p class="muted" id="statusText" style="margin:0;">Chargementâ€¦</p>

    <div class="grid" style="margin-top:12px;">
      <button class="btn" id="btnReplay" style="font-weight:900; color:#111; display:none;">â–¶ï¸ Replay roulette</button>
      <button class="btn" id="btnStopReplay" style="font-weight:900; color:#111; display:none;">â¹ï¸ Stop replay</button>
    </div>

    <p class="muted" id="modeBadge" style="margin-top:10px;"></p>
    <p class="muted" id="validatedAt" style="margin-top:6px;"></p>
  </section>

  <section class="card" id="panelMain" style="display:none;">
    <div class="grid">
      <div class="card" style="margin:0;">
        <div style="font-weight:1000;">ğŸ·ï¸ TÃªte de sÃ©rie #1</div>
        <div class="muted" id="seed1">â€”</div>
      </div>
      <div class="card" style="margin:0;">
        <div style="font-weight:1000;">ğŸ·ï¸ TÃªte de sÃ©rie #2</div>
        <div class="muted" id="seed2">â€”</div>
      </div>
    </div>

    <div style="margin-top:12px;">
      <div style="font-weight:1000; margin-bottom:8px;">ğŸ° Roulette</div>
      <div class="roulette-wheel" id="wheel">â€”</div>
      <div class="muted" id="wheelSub" style="margin-top:8px;">â€”</div>
    </div>

    <!-- âœ… ORDRE DEMANDÃ‰ : rÃ©vÃ©lÃ©s puis urne -->
    <div style="margin-top:12px;">
      <div style="font-weight:1000; margin-bottom:8px;">ğŸ“Œ Tirages rÃ©vÃ©lÃ©s</div>
      <div id="revealedList" style="display:grid; gap:8px;"></div>
    </div>

    <div style="margin-top:12px;" id="urneBlock">
      <div style="font-weight:1000; margin-bottom:8px;">ğŸ“¥ Urne (Ã©quipes restantes)</div>
      <div id="urneList" style="display:grid; gap:8px;"></div>
    </div>
  </section>

  <section class="card" id="panelMatches" style="display:none;">
    <h2 style="margin:0 0 10px;">ğŸ“‹ Affiche des matchs</h2>
    <div class="table-wrap">
      <table class="teams-table" aria-label="Matchs">
        <thead>
          <tr>
            <th style="width:60px;">Match</th>
            <th>Ã‰quipe A</th>
            <th>Ã‰quipe B</th>
          </tr>
        </thead>
        <tbody id="matchBody"></tbody>
      </table>
    </div>
    <p class="muted" style="margin-top:10px;">
      Rappel : 1Ã¨re tirÃ©e vs TS1, 2e vs 3e, 4e vs 5e, 6e vs TS2.
    </p>
  </section>

</main>

<style>
  .roulette-wheel{
    height:68px;
    border-radius:14px;
    border:1px solid #e6e6e6;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:1000;
    font-size:18px;
    letter-spacing:.2px;
    background:linear-gradient(180deg,#fff,#fafafa);
  }
  .pill{
    display:inline-block;
    padding:4px 10px;
    border-radius:999px;
    font-size:12px;
    border:1px solid #eee;
    background:#fafafa;
    white-space:nowrap;
  }
  .table-wrap{ overflow:auto; border:1px solid #eee; border-radius:14px; background:#fff; }
  .teams-table{ width:100%; border-collapse:separate; border-spacing:0; min-width:700px; }
  .teams-table thead th{
    text-align:left; font-size:13px; color:#444; background:#f7f7f7;
    border-bottom:1px solid #eee; padding:12px; position:sticky; top:0; z-index:1;
    white-space:nowrap;
  }
  .teams-table tbody td{ padding:12px; border-bottom:1px solid #f0f0f0; font-size:14px; vertical-align:top; }
  .teams-table tbody tr:last-child td{ border-bottom:none; }
</style>

<script type="module">
  import { db } from "../assets/js/firebase.js";
  import { doc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  const scope = "etape5";
  const DRAW_REF = doc(db, "tirages", scope);

  const statusText = document.getElementById("statusText");
  const modeBadge = document.getElementById("modeBadge");
  const validatedAtEl = document.getElementById("validatedAt");

  const panelMain = document.getElementById("panelMain");
  const panelMatches = document.getElementById("panelMatches");

  const seed1El = document.getElementById("seed1");
  const seed2El = document.getElementById("seed2");

  const wheel = document.getElementById("wheel");
  const wheelSub = document.getElementById("wheelSub");

  const urneBlock = document.getElementById("urneBlock");
  const urneList = document.getElementById("urneList");
  const revealedList = document.getElementById("revealedList");
  const matchBody = document.getElementById("matchBody");

  const btnReplay = document.getElementById("btnReplay");
  const btnStopReplay = document.getElementById("btnStopReplay");

  let currentDraw = null;

  // LIVE reveal
  let shownCount = 0;
  let revealedShownIds = [];
  let liveAnimating = false;

  // Replay
  let replayMode = false;
  let replayAbort = false;

  function esc(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function teamLabel(t){
    if(!t) return "â€”";
    return `${t.teamName || "Ã‰quipe"} (${t.p1FirstName || "?"} / ${t.p2FirstName || "?"})`;
  }

  function fmtDate(ts){
    try{
      const d = ts?.toDate ? ts.toDate() : null;
      if(!d) return "";
      return d.toLocaleString("fr-FR", { year:"numeric", month:"long", day:"numeric", hour:"2-digit", minute:"2-digit" });
    }catch{ return ""; }
  }

  function drawHasUrn(draw){
    return !!(draw && draw.seed1 && draw.seed2 && Array.isArray(draw.pool) && draw.pool.length === 6);
  }

  async function rouletteSpin(finalText, durationMs = 1300){
    const start = Date.now();
    wheelSub.textContent = replayMode ? "Replay en coursâ€¦" : "La roulette tourneâ€¦";
    const fake = ["ğŸŒªï¸","ğŸ¾","ğŸ”¥","ğŸ€","âš¡ï¸","ğŸ²","ğŸ–ï¸"];

    return new Promise((resolve) => {
      const tick = () => {
        if(replayAbort){ resolve("aborted"); return; }
        const t = Date.now() - start;
        if(t >= durationMs){
          wheel.textContent = finalText;
          wheelSub.textContent = "âœ… RÃ©vÃ©lÃ©";
          resolve("done");
          return;
        }
        wheel.textContent = fake[Math.floor(Math.random()*fake.length)] + " " + fake[Math.floor(Math.random()*fake.length)];
        requestAnimationFrame(tick);
      };
      tick();
    });
  }

  function computeLists(draw){
    const order = draw?.order || [];
    const pool = draw?.pool || [];
    const poolById = new Map(pool.map(x => [x.id, x]));

    const revealed = Number(draw?.revealed || 0);

    // revealedIds uniquement si order existe
    const revealedIds = order.slice(0, revealed);
    const remainingIds = order.length
      ? order.slice(revealed)
      : pool.map(x => x.id); // idle => urne complÃ¨te

    const revealedTeams = revealedIds.map(id => poolById.get(id)).filter(Boolean);
    const remainingTeams = remainingIds.map(id => poolById.get(id)).filter(Boolean);

    return { poolById, revealedIds, revealedTeams, remainingTeams };
  }

  function renderUrne(remainingTeams, draw){
    if(!drawHasUrn(draw)){
      urneBlock.style.display = "none";
      urneList.innerHTML = "";
      return;
    }

    const revealed = Number(draw?.revealed || 0);

    // âœ… Urne visible en idle + running, disparait Ã  6/6
    if(!remainingTeams.length || revealed >= 6){
      urneBlock.style.display = "none";
      urneList.innerHTML = "";
      return;
    }

    urneBlock.style.display = "block";
    urneList.innerHTML = remainingTeams.map(t => `
      <div class="card" style="margin:0;">
        <div style="display:flex;justify-content:space-between;gap:10px;">
          <div><b>${esc(teamLabel(t))}</b></div>
          <span class="pill">urne</span>
        </div>
      </div>
    `).join("");
  }

  function renderRevealedList(teams){
    revealedList.innerHTML = teams.length
      ? teams.map((t,i)=> `
        <div class="card" style="margin:0;">
          <div style="display:flex;justify-content:space-between;gap:10px;">
            <div><b>#${i+1}</b> â€” ${esc(teamLabel(t))}</div>
            <span class="pill">tirÃ©e</span>
          </div>
        </div>
      `).join("")
      : `<div class="muted">En attenteâ€¦</div>`;
  }

  function renderMatches(draw){
    const seed1 = draw?.seed1 || null;
    const seed2 = draw?.seed2 || null;
    const { revealedTeams } = computeLists(draw);

    if(revealedTeams.length < 6){
      panelMatches.style.display = "none";
      matchBody.innerHTML = "";
      return;
    }

    const p1 = revealedTeams[0];
    const p2 = revealedTeams[1];
    const p3 = revealedTeams[2];
    const p4 = revealedTeams[3];
    const p5 = revealedTeams[4];
    const p6 = revealedTeams[5];

    const matches = [
      { n: 1, A: seed1, B: p1 },
      { n: 2, A: p2, B: p3 },
      { n: 3, A: p4, B: p5 },
      { n: 4, A: p6, B: seed2 }
    ];

    matchBody.innerHTML = matches.map(m => `
      <tr>
        <td><b>#${m.n}</b></td>
        <td>${esc(teamLabel(m.A))}</td>
        <td>${esc(teamLabel(m.B))}</td>
      </tr>
    `).join("");

    panelMatches.style.display = "block";
  }

  function updateHeader(draw){
    panelMain.style.display = "block";
    seed1El.textContent = draw?.seed1 ? teamLabel(draw.seed1) : "â€”";
    seed2El.textContent = draw?.seed2 ? teamLabel(draw.seed2) : "â€”";
  }

  function updateStatus(draw){
    const st = draw?.status || "idle";
    const revealed = Number(draw?.revealed || 0);

    // âœ… badge direct/replay
    if(replayMode){
      modeBadge.textContent = "ğŸ¥ Mode REPLAY";
    } else if(st === "running"){
      modeBadge.textContent = "ğŸŸ¢ En direct";
    } else {
      modeBadge.textContent = "";
    }

    if(!draw){
      statusText.textContent = "â³ Tirage non prÃªt.";
      validatedAtEl.textContent = "";
      return;
    }

    // âœ… IDLE : seulement si urne chargÃ©e, sinon â€œpas prÃªteâ€
    if(st === "idle"){
      if(drawHasUrn(draw)){
        statusText.textContent = "ğŸ“¥ Urne chargÃ©e. Tirage pas encore lancÃ©.";
      } else {
        statusText.textContent = "â³ Urne non prÃªte (en attente du chargement cÃ´tÃ© admin).";
      }
      validatedAtEl.textContent = "";
      return;
    }

    if(st === "running"){
      statusText.textContent = `ğŸ° Tirage en coursâ€¦ (${revealed}/6 rÃ©vÃ©lÃ©es)`;
      validatedAtEl.textContent = "";
      return;
    }

    if(st === "pending_validation"){
      statusText.textContent = "ğŸ Tirage fini â€” en attente de validation par le comitÃ© du tournoi.";
      validatedAtEl.textContent = "";
      return;
    }

    if(st === "validated"){
      statusText.textContent = "âœ… Tirage validÃ©.";
      const d = fmtDate(draw.validatedAt);
      validatedAtEl.textContent = d ? ("ğŸ—“ï¸ ValidÃ© le " + d) : "";
      return;
    }

    statusText.textContent = "â€”";
  }

  async function applyLiveRevealAnimation(draw){
    if(replayMode) return;
    if(liveAnimating) return;

    const st = draw?.status || "idle";
    if(st !== "running" && st !== "pending_validation" && st !== "validated"){
      // idle : on affiche urne si dispo, rÃ©vÃ©lÃ©s vide
      const { remainingTeams } = computeLists(draw);
      renderRevealedList([]);
      renderUrne(remainingTeams, draw);
      renderMatches(draw);
      return;
    }

    const { poolById, revealedIds, remainingTeams } = computeLists(draw);

    // urne toujours Ã  jour
    renderUrne(remainingTeams, draw);

    // rien de nouveau
    if(revealedIds.length <= shownCount){
      const shownTeams = revealedShownIds.map(id => poolById.get(id)).filter(Boolean);
      renderRevealedList(shownTeams);
      renderMatches(draw);
      return;
    }

    liveAnimating = true;

    while(shownCount < revealedIds.length){
      const id = revealedIds[shownCount];
      const t = poolById.get(id);

      await rouletteSpin(teamLabel(t), 1300);

      revealedShownIds.push(id);
      shownCount++;

      const shownTeams = revealedShownIds.map(x => poolById.get(x)).filter(Boolean);
      renderRevealedList(shownTeams);
      renderMatches(draw);

      // recalcul urne et masque si 6/6
      const { remainingTeams: rem2 } = computeLists(currentDraw);
      renderUrne(rem2, currentDraw);
    }

    liveAnimating = false;
  }

  async function doReplay(draw){
    if(!draw || draw.status !== "validated"){
      alert("Replay disponible uniquement quand le tirage est validÃ©.");
      return;
    }

    replayMode = true;
    replayAbort = false;
    btnReplay.style.display = "none";
    btnStopReplay.style.display = "inline-flex";

    updateStatus(draw);

    const { poolById, revealedIds } = computeLists(draw);

    // reset affichage
    shownCount = 0;
    revealedShownIds = [];
    wheel.textContent = "â€”";
    wheelSub.textContent = "Replay en coursâ€¦";
    renderRevealedList([]);

    // urne cachÃ©e en replay
    urneBlock.style.display = "none";

    for(let i=0;i<revealedIds.length;i++){
      if(replayAbort) break;
      const id = revealedIds[i];
      const t = poolById.get(id);

      await rouletteSpin(teamLabel(t), 1300);
      revealedShownIds.push(id);

      const shownTeams = revealedShownIds.map(x => poolById.get(x)).filter(Boolean);
      renderRevealedList(shownTeams);
      renderMatches(draw);
    }

    btnStopReplay.style.display = "none";
    btnReplay.style.display = "inline-flex";

    replayMode = false;
    replayAbort = false;

    updateStatus(currentDraw);
    wheelSub.textContent = "âœ… Replay terminÃ©";
  }

  btnReplay.onclick = async (e)=>{
    e.preventDefault();
    await doReplay(currentDraw);
  };

  btnStopReplay.onclick = (e)=>{
    e.preventDefault();
    replayAbort = true;
  };

  onSnapshot(DRAW_REF, async (snap)=>{
    currentDraw = snap.exists() ? (snap.data() || {}) : null;

    if(!currentDraw){
      panelMain.style.display = "none";
      panelMatches.style.display = "none";
      btnReplay.style.display = "none";
      btnStopReplay.style.display = "none";
      statusText.textContent = "â³ Tirage non prÃªt.";
      modeBadge.textContent = "";
      validatedAtEl.textContent = "";
      return;
    }

    updateHeader(currentDraw);
    updateStatus(currentDraw);

    // bouton replay visible uniquement si validated
    if(currentDraw.status === "validated"){
      if(!replayMode) btnReplay.style.display = "inline-flex";
    } else {
      btnReplay.style.display = "none";
      btnStopReplay.style.display = "none";
    }

    // idle : afficher urne si dispo, rÃ©vÃ©lÃ©s vides
    if(!replayMode && currentDraw.status === "idle"){
      shownCount = 0;
      revealedShownIds = [];
      wheel.textContent = "â€”";
      wheelSub.textContent = "â€”";
      const { remainingTeams } = computeLists(currentDraw);
      renderRevealedList([]);
      renderUrne(remainingTeams, currentDraw);
      renderMatches(currentDraw);
      return;
    }

    // LIVE : animation + reveal
    if(!replayMode){
      await applyLiveRevealAnimation(currentDraw);
    }
  }, (err)=>{
    console.error(err);
    statusText.textContent = "ğŸ”´ Erreur de connexion au tirage.";
  });
</script>

</body>
</html>
