<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin ‚Äî Programmation</title>
  <link rel="stylesheet" href="../assets/css/main.css?v=20260222" />
</head>
<body>

<header class="topbar">
  <div class="container">
    <div class="topbar-row">
      <div class="brand-logo">
        <img src="../assets/img/logo-suzini.png" alt="Logo Suzini">
      </div>

      <h1 class="brand-title">
        üìÖ Programmation (admin)<br>
        <span style="opacity:.95;font-weight:800;" id="pageSub">√âtape ‚Äî</span>
      </h1>

      <div class="brand-logo">
        <img src="../assets/img/logo-challenge.png" alt="Logo Challenge">
      </div>
    </div>

    <nav class="nav">
      <a href="../index.html">Accueil public</a>
      <a href="#" id="btnLogout">D√©connexion</a>
    </nav>
  </div>
</header>

<main class="container">

  <section class="card" id="accessDenied" style="display:none;">
    <h2 style="margin:0 0 8px;">‚õî Acc√®s refus√©</h2>
    <p class="muted" style="margin:0;">Cette page est r√©serv√©e aux administrateurs.</p>
  </section>

  <section class="card" id="adminUI" style="display:none;">
    <h2 style="margin:0 0 10px;">üéõÔ∏è Zone</h2>

    <div class="field">
      <label for="scope">Choisir</label>
      <select id="scope">
        <option value="general">G√©n√©ral</option>
        <option value="etape1">√âtape 1</option>
        <option value="etape2">√âtape 2</option>
        <option value="etape3">√âtape 3</option>
        <option value="etape4">√âtape 4</option>
        <option value="etape5">√âtape 5</option>
      </select>
    </div>

    <div class="grid" style="margin-top:10px;" id="tabs"></div>
    <p class="muted" id="hint" style="margin-top:10px;"></p>
  </section>

  <section class="card" id="panelNeedStep" style="display:none;">
    <h2 style="margin:0 0 8px;">‚ÑπÔ∏è Choisir une √©tape</h2>
    <p class="muted" style="margin:0;">
      S√©lectionne une <b>√âtape</b> dans ‚ÄúZone‚Äù pour g√©rer la programmation.
    </p>
  </section>

  <section class="card" id="panelBuild" style="display:none;">
    <h2 style="margin:0 0 10px;">‚öôÔ∏è G√©n√©ration (selon r√®glement)</h2>
    <p class="muted" id="buildStatus" style="margin:0;">Chargement‚Ä¶</p>

    <div class="grid" style="margin-top:12px;">
      <button class="btn" id="btnGenerate" style="font-weight:900; color:#111;">
        üß© G√©n√©rer la programmation depuis le tirage VALID√â
      </button>

      <button class="btn" id="btnOpenPublic" style="font-weight:900; color:#111;">
        üëÄ Ouvrir la programmation (public)
      </button>
    </div>

    <p class="muted" style="margin-top:12px;">
      ‚úÖ Le tableau est charg√© d√®s la <b>validation du tirage</b>. Les matchs suivants se ‚Äúremplissent‚Äù au fur et √† mesure
      de la validation des r√©sultats (page admin/resultats).
    </p>
  </section>

  <section class="card" id="panelSchedule" style="display:none;">
    <h2 style="margin:0 0 10px;">üóìÔ∏è Ordre chronologique</h2>
    <p class="muted" id="schedStatus" style="margin:0;">‚Äî</p>

    <div id="schedCards" style="display:grid; gap:12px; margin-top:12px;"></div>

    <p class="muted" style="margin-top:10px;">
      üí° Les boutons ‚Üë ‚Üì √©changent les <b>cr√©neaux</b> (heure/terrain) entre matchs.
    </p>
  </section>

</main>

<style>
  .pill{
    display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px;
    border:1px solid #eee; background:#fafafa; white-space:nowrap;
  }

  /* --- Match cards (responsive) --- */
  .match-card{
    border-radius:16px;
    border:1px solid rgba(0,0,0,.06);
    overflow:hidden;
    background:#fff;
  }
  .match-card.yellow{ background:rgba(255, 221, 87, .22); border-color:rgba(255, 221, 87, .55); }
  .match-card.red{ background:rgba(255, 77, 77, .12); border-color:rgba(255, 77, 77, .28); }

  .match-inner{
    padding:12px;
    display:flex;
    gap:12px;
    align-items:stretch;
  }

  .match-left{ flex:1 1 auto; min-width:0; }

  .match-topline{
    display:flex;
    justify-content:space-between;
    align-items:baseline;
    gap:10px;
    flex-wrap:nowrap;
  }

  .when-line{
    display:flex;
    align-items:baseline;
    gap:10px;
    min-width:0;
    flex-wrap:nowrap;
  }

  .when-time{
    font-weight:1000;
    font-size:20px;
    letter-spacing:.2px;
    white-space:nowrap;
  }

  /* court small, non-bold, single line */
  .when-court{
    font-size:13px;
    font-weight:600; /* pas gras ‚Äúlourd‚Äù */
    opacity:.92;
    font-style:italic;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  .status-emoji{
    font-size:18px;
    line-height:1;
    white-space:nowrap;
  }

  .teams{
    margin-top:10px;
    display:grid;
    gap:8px;
  }
  .team-name{
    font-weight:950;
    font-size:18px;
    line-height:1.15;
    word-break:break-word;
  }
  .vsline{
    text-align:center;
    font-weight:900;
    opacity:.55;
    letter-spacing:.25em;
  }

  .match-right{
    width:92px;
    flex:0 0 auto;
    display:flex;
    flex-direction:column;
    gap:10px;
    align-items:stretch;
    justify-content:space-between;
  }

  .scorebox{
    border:1px solid rgba(0,0,0,.08);
    background:rgba(255,255,255,.70);
    border-radius:16px;
    padding:10px 10px;
    display:flex;
    flex-direction:column;
    gap:10px;
    justify-content:center;
  }
  .scoreline{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    font-weight:1000;
  }
  .scoreval{
    font-size:18px;
    line-height:1;
    min-width:18px;
    text-align:right;
  }

  .actions{
    display:flex;
    gap:8px;
    justify-content:flex-end;
  }

  .btnx{
    padding:10px 12px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.12);
    background:#fff;
    cursor:pointer;
    font-weight:900;
    line-height:1;
  }
  .btnx:hover{ background:rgba(255,255,255,.7); }
  .btnx:disabled{ opacity:.5; cursor:not-allowed; }

  .muted-mini{
    font-size:12px;
    opacity:.7;
  }

  @media (max-width: 420px){
    .match-inner{ padding:10px; gap:10px; }
    .when-time{ font-size:18px; }
    .team-name{ font-size:16px; }
    .match-right{ width:86px; }
    .scoreval{ font-size:16px; }
    .btnx{ padding:10px 11px; }
  }
</style>

<script type="module">
  import { auth, db } from "../assets/js/firebase.js";
  import { logout, requireRole } from "../assets/js/session.js";

  import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
  import {
    doc, getDoc, setDoc, updateDoc, onSnapshot,
    serverTimestamp, collection
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  // ---- scope (URL ?scope=etape5)
  const params = new URLSearchParams(location.search);
  const scopeFromUrl = params.get("scope") || "etape5";

  // ---- DOM
  const accessDenied = document.getElementById("accessDenied");
  const adminUI = document.getElementById("adminUI");

  const scopeEl = document.getElementById("scope");
  const tabsEl  = document.getElementById("tabs");
  const hintEl  = document.getElementById("hint");
  const pageSub = document.getElementById("pageSub");

  const panelNeedStep = document.getElementById("panelNeedStep");
  const panelBuild = document.getElementById("panelBuild");
  const panelSchedule = document.getElementById("panelSchedule");

  const buildStatus = document.getElementById("buildStatus");
  const schedStatus = document.getElementById("schedStatus");
  const schedCards = document.getElementById("schedCards");

  const btnGenerate = document.getElementById("btnGenerate");
  const btnOpenPublic = document.getElementById("btnOpenPublic");

  // ---- state
  let currentScope = scopeFromUrl;
  let unsubProg = null;
  let unsubRes = null;
  let currentProg = null;

  let resultsByMatch = new Map(); // matchId -> {winnerSide, scoreA, scoreB, score, updatedAt}
  let scheduleRowCount = 12;

  function stepLabel(scope){
    if(!scope || scope === "general") return "G√©n√©ral";
    const n = scope.replace("etape","");
    return `√âtape ${n}`;
  }

  function esc(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function setTabs(scope){
    tabsEl.innerHTML = "";

    if(scope === "general"){
      hintEl.textContent = "Zone G√©n√©ral : se g√®re depuis admin/index.html (infos).";
      const a = document.createElement("a");
      a.className = "btn";
      a.href = "index.html";
      a.textContent = "üì∞ Aller aux infos (G√©n√©ral)";
      tabsEl.appendChild(a);
      return;
    }

    hintEl.textContent = "Zone √âtape : √©quipes / inscriptions / tirage / programmation / r√©sultats.";

    const links = [
      ["üë• √âquipes", "equipes.html"],
      ["üìù Inscriptions", "inscriptions.html"],
      ["üé≤ Tirage", "tirage.html"],
      ["üìÖ Programmation", "programmation.html"],
      ["üèÅ R√©sultats", "resultats.html"],
    ];

    for(const [label, url] of links){
      const a = document.createElement("a");
      a.className = "btn";
      a.href = `${url}?scope=${encodeURIComponent(scope)}`;
      a.textContent = label;
      if(url === "programmation.html") a.style.fontWeight = "900";
      tabsEl.appendChild(a);
    }
  }

  function stopListeners(){
    if(unsubProg){ unsubProg(); unsubProg = null; }
    if(unsubRes){ unsubRes(); unsubRes = null; }
  }

  function showPanelsForScope(scope){
    pageSub.textContent = scope === "general" ? "G√©n√©ral" : `${stepLabel(scope)} ‚Äî BT250`;

    if(scope === "general"){
      panelNeedStep.style.display = "block";
      panelBuild.style.display = "none";
      panelSchedule.style.display = "none";
      stopListeners();
      return;
    }

    panelNeedStep.style.display = "none";
    panelBuild.style.display = "block";
    panelSchedule.style.display = "block";

    startProgListener(scope);
    startResultsListener(scope);
  }

  // ---- Courts (fixes)
  function defaultCourts(){
    return {
      A: "court Manon Queen Bee",
      B: "court Lisa de Los Pimentos"
    };
  }

  // ---- mod√®le "r√®glement" (matches fixes)
  function buildMatches(){
    return {
      M1:  { id:"M1",  n:1,  bracket:"main", round:"QF", A:{type:"team", key:"E4"},  B:{type:"team", key:"E5"}  },
      M2:  { id:"M2",  n:2,  bracket:"main", round:"QF", A:{type:"team", key:"E6"},  B:{type:"team", key:"E7"}  },
      M3:  { id:"M3",  n:3,  bracket:"main", round:"QF", A:{type:"team", key:"TS1"}, B:{type:"team", key:"E3"}  },
      M4:  { id:"M4",  n:4,  bracket:"main", round:"QF", A:{type:"team", key:"TS2"}, B:{type:"team", key:"E8"}  },

      M5:  { id:"M5",  n:5,  bracket:"5-8", round:"SF", A:{type:"loser", matchId:"M1"}, B:{type:"loser", matchId:"M2"} },
      M6:  { id:"M6",  n:6,  bracket:"5-8", round:"SF", A:{type:"loser", matchId:"M3"}, B:{type:"loser", matchId:"M4"} },

      M7:  { id:"M7",  n:7,  bracket:"main", round:"SF", A:{type:"winner", matchId:"M1"}, B:{type:"winner", matchId:"M2"} },
      M8:  { id:"M8",  n:8,  bracket:"main", round:"SF", A:{type:"winner", matchId:"M3"}, B:{type:"winner", matchId:"M4"} },

      M9:  { id:"M9",  n:9,  bracket:"5-8", round:"7th", A:{type:"loser", matchId:"M5"}, B:{type:"loser", matchId:"M6"} },
      M10: { id:"M10", n:10, bracket:"5-8", round:"5th", A:{type:"winner", matchId:"M5"}, B:{type:"winner", matchId:"M6"} },

      M11: { id:"M11", n:11, bracket:"main", round:"3rd", A:{type:"loser", matchId:"M7"}, B:{type:"loser", matchId:"M8"} },
      M12: { id:"M12", n:12, bracket:"main", round:"F",   A:{type:"winner", matchId:"M7"}, B:{type:"winner", matchId:"M8"} },
    };
  }

  function defaultSlots(){
    return [
      { slot:1,  time:"18:00", court:"A" },
      { slot:2,  time:"18:00", court:"B" },
      { slot:3,  time:"18:50", court:"A" },
      { slot:4,  time:"18:50", court:"B" },
      { slot:5,  time:"19:40", court:"A" },
      { slot:6,  time:"20:05", court:"B", note:"pause sp√©cifique avant ce match" },
      { slot:7,  time:"20:30", court:"A" },
      { slot:8,  time:"20:55", court:"B" },
      { slot:9,  time:"21:20", court:"A" },
      { slot:10, time:"21:45", court:"B" },
      { slot:11, time:"22:10", court:"A" },
      { slot:12, time:"22:35", court:"B" },
    ];
  }

  // ---- Firestore refs
  function progRef(scope){ return doc(db, "programmations", scope); }
  function drawRef(scope){ return doc(db, "tirages", scope); }
  function resultsCol(scope){ return collection(db, `resultats_${scope}`); }

  async function generateFromValidatedDraw(scope){
    const dSnap = await getDoc(drawRef(scope));
    if(!dSnap.exists()) throw new Error("Tirage introuvable.");
    const draw = dSnap.data() || {};
    if(draw.status !== "validated") throw new Error("Le tirage doit √™tre VALID√â avant de g√©n√©rer la programmation.");

    const order = draw.order || [];
    const pool = draw.pool || [];
    const poolById = new Map(pool.map(x => [x.id, x]));
    const revealed = Number(draw.revealed || 0);

    if(revealed < 6) throw new Error("Il faut 6 √©quipes tir√©es (tirage complet) avant validation.");

    const picks = order.slice(0, 6).map(id => poolById.get(id)).filter(Boolean);
    if(picks.length !== 6) throw new Error("Impossible de reconstruire E3..E8 depuis le tirage.");

    const teams = {
      TS1: draw.seed1 || null,
      TS2: draw.seed2 || null,
      E3: picks[0] || null,
      E4: picks[1] || null,
      E5: picks[2] || null,
      E6: picks[3] || null,
      E7: picks[4] || null,
      E8: picks[5] || null,
    };

    if(!teams.TS1 || !teams.TS2) throw new Error("Seeds manquantes.");
    for(const k of ["E3","E4","E5","E6","E7","E8"]){
      if(!teams[k]) throw new Error("√âquipe manquante : " + k);
    }

    const matches = buildMatches();
    const slots = defaultSlots();
    const courts = defaultCourts();

    const schedule = {};
    Object.keys(matches).forEach((mid)=>{
      schedule[mid] = matches[mid].n;
    });

    const payload = {
      formatVersion: 2,
      scope,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      courts,
      source: {
        drawValidatedAt: draw.validatedAt || null,
        drawDoc: "tirages/" + scope
      },
      teams,
      matches,
      slots,
      schedule
    };

    await setDoc(progRef(scope), payload, { merge:true });
    return payload;
  }

  function courtName(prog, courtKey){
    const c = prog?.courts || {};
    return c[courtKey] || (courtKey || "‚Äî");
  }

  function courtDecor(courtKey){
    if(courtKey === "A") return { cls:"yellow", emo:"üêù", label:"court Manon Queen Bee" };
    if(courtKey === "B") return { cls:"red", emo:"üå∂Ô∏è", label:"court Lisa de Los Pimentos" };
    return { cls:"", emo:"üéæ", label:"Court" };
  }

  function teamLabel(t){
    if(!t) return "‚Äî";
    return `${t.teamName || "√âquipe"} (${t.p1FirstName || "?"} / ${t.p2FirstName || "?"})`;
  }

  // R√©solution des √©quipes (direct / winner / loser)
  function resolveTeamRef(ref){
    if(!currentProg) return null;

    const teams = currentProg.teams || {};
    const matches = currentProg.matches || {};

    if(!ref) return null;

    if(ref.type === "team"){
      return teams[ref.key] || null;
    }

    if(ref.type === "winner" || ref.type === "loser"){
      const mid = ref.matchId;
      const m = matches[mid];
      if(!m) return null;

      const res = resultsByMatch.get(mid);
      if(!res || (res.winnerSide !== "A" && res.winnerSide !== "B")) return null;

      const teamA = resolveTeamRef(m.A);
      const teamB = resolveTeamRef(m.B);

      const winner = (res.winnerSide === "A") ? teamA : teamB;
      const loser  = (res.winnerSide === "A") ? teamB : teamA;

      return ref.type === "winner" ? winner : loser;
    }

    return null;
  }

  function parseHHMM(hhmm){
    const m = String(hhmm || "").match(/^(\d{1,2}):(\d{2})$/);
    if(!m) return null;
    const H = Number(m[1]), M = Number(m[2]);
    if(!Number.isFinite(H) || !Number.isFinite(M)) return null;
    return { H, M };
  }

  function statusEmoji(slotTime, done){
    if(done) return "‚úÖ";
    const p = parseHHMM(slotTime);
    if(!p) return "‚è≥";
    const now = new Date();
    const start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), p.H, p.M, 0, 0);
    // Heuristique ‚Äúen cours‚Äù si on a d√©pass√© l'heure (sans r√©sultat)
    return now >= start ? "üü¢" : "‚è≥";
  }

  function scoreForMatch(mid){
    const r = resultsByMatch.get(mid);
    if(!r) return { A:"‚Äî", B:"‚Äî", done:false };
    const A = (r.scoreA ?? "‚Äî");
    const B = (r.scoreB ?? "‚Äî");
    const done = !!(r.winnerSide === "A" || r.winnerSide === "B");
    return { A, B, done };
  }

  function renderSchedule(prog){
    const matches = prog?.matches || {};
    const slots = Array.isArray(prog?.slots) ? prog.slots : [];
    const schedule = prog?.schedule || {};

    scheduleRowCount = slots.length || 12;

    // slot -> matchId
    const slotToMatch = new Map();
    Object.entries(schedule).forEach(([mid, slotNum])=>{
      slotToMatch.set(Number(slotNum), mid);
    });

    const cards = [];

    for(const s of slots){
      const mid = slotToMatch.get(Number(s.slot)) || null;
      const m = mid ? matches[mid] : null;
      if(!m || !mid) continue;

      const teamA = resolveTeamRef(m.A);
      const teamB = resolveTeamRef(m.B);

      const aTxt = teamA ? teamLabel(teamA) : (m.A.type === "team" ? m.A.key : (m.A.type === "winner" ? `V${m.A.matchId.slice(1)}` : `P${m.A.matchId.slice(1)}`));
      const bTxt = teamB ? teamLabel(teamB) : (m.B.type === "team" ? m.B.key : (m.B.type === "winner" ? `V${m.B.matchId.slice(1)}` : `P${m.B.matchId.slice(1)}`));

      const courtKey = s.court;
      const court = courtDecor(courtKey);
      const courtTxt = courtName(prog, courtKey);

      const sc = scoreForMatch(mid);
      const st = statusEmoji(s.time, sc.done);

      cards.push(`
        <div class="match-card ${esc(court.cls)}">
          <div class="match-inner">
            <div class="match-left">
              <div class="match-topline">
                <div class="when-line">
                  <div class="when-time">#${esc(s.slot)}&nbsp;${esc(s.time)}</div>
                  <div class="when-court">${esc(court.emo)} ${esc(courtTxt)} ${esc(court.emo)}</div>
                </div>
                <div class="status-emoji" title="Statut">${esc(st)}</div>
              </div>

              ${s.note ? `<div class="muted-mini" style="margin-top:6px;">‚ö†Ô∏è ${esc(s.note)}</div>` : ""}

              <div class="teams">
                <div class="team-name">${esc(aTxt)}</div>
                <div class="vsline">VS</div>
                <div class="team-name">${esc(bTxt)}</div>
              </div>
            </div>

            <div class="match-right">
              <div class="scorebox" aria-label="Score">
                <div class="scoreline"><span class="muted-mini">A</span><span class="scoreval">${esc(sc.A)}</span></div>
                <div class="scoreline"><span class="muted-mini">B</span><span class="scoreval">${esc(sc.B)}</span></div>
              </div>

              <div class="actions">
                <button class="btnx" data-act="up" data-slot="${esc(s.slot)}" ${s.slot<=1 ? "disabled":""}>‚Üë</button>
                <button class="btnx" data-act="down" data-slot="${esc(s.slot)}" ${s.slot>=scheduleRowCount ? "disabled":""}>‚Üì</button>
              </div>
            </div>
          </div>
        </div>
      `);
    }

    schedCards.innerHTML = cards.join("") || `<div class="muted">‚Äî</div>`;
    schedStatus.textContent = "‚úÖ OK";
  }

  async function swapSlots(scope, slotA, slotB){
    const ref = progRef(scope);
    const snap = await getDoc(ref);
    if(!snap.exists()) throw new Error("Programmation introuvable.");

    const prog = snap.data() || {};
    const schedule = prog.schedule || {};

    // slot -> matchId
    const slotToMatch = new Map();
    Object.entries(schedule).forEach(([mid, s]) => slotToMatch.set(Number(s), mid));

    const mA = slotToMatch.get(Number(slotA)) || null;
    const mB = slotToMatch.get(Number(slotB)) || null;

    const newSchedule = { ...schedule };
    if(mA) newSchedule[mA] = Number(slotB);
    if(mB) newSchedule[mB] = Number(slotA);

    await updateDoc(ref, { schedule: newSchedule, updatedAt: serverTimestamp() });
  }

  function startProgListener(scope){
    if(unsubProg){ unsubProg(); unsubProg = null; }

    buildStatus.textContent = "Chargement‚Ä¶";
    schedStatus.textContent = "Chargement‚Ä¶";
    schedCards.innerHTML = "";

    unsubProg = onSnapshot(progRef(scope), (snap)=>{
      currentProg = snap.exists() ? (snap.data() || {}) : null;

      if(!currentProg){
        buildStatus.textContent = "‚ÑπÔ∏è Aucune programmation enregistr√©e pour cette √©tape. G√©n√®re-la depuis le tirage valid√©.";
        schedStatus.textContent = "‚Äî";
        schedCards.innerHTML = "";
        return;
      }

      buildStatus.textContent = "‚úÖ Programmation pr√©sente (mise √† jour auto en public).";
      renderSchedule(currentProg);
    }, (err)=>{
      console.error(err);
      buildStatus.textContent = "‚ùå Erreur Firestore (programmation).";
      schedStatus.textContent = "‚ùå Erreur";
    });
  }

  function startResultsListener(scope){
    if(unsubRes){ unsubRes(); unsubRes = null; }

    unsubRes = onSnapshot(resultsCol(scope), (snap)=>{
      resultsByMatch = new Map();
      snap.forEach(d=>{
        const x = d.data() || {};
        resultsByMatch.set(d.id, {
          winnerSide: x.winnerSide || null,
          score: x.score || "",
          // scoreA/scoreB : on les utilisera si tu les stockes dans resultats (recommand√©).
          scoreA: x.scoreA ?? null,
          scoreB: x.scoreB ?? null,
          updatedAt: x.updatedAt || null
        });
      });
      if(currentProg) renderSchedule(currentProg);
    });
  }

  // ---- Events
  btnGenerate.onclick = async (e)=>{
    e.preventDefault();
    if(currentScope === "general"){ alert("Choisis une √©tape."); return; }

    btnGenerate.disabled = true;
    btnGenerate.classList.add("disabled");
    buildStatus.textContent = "G√©n√©ration‚Ä¶";

    try{
      await generateFromValidatedDraw(currentScope);
      buildStatus.textContent = "‚úÖ Programmation g√©n√©r√©e depuis le tirage VALID√â.";
    }catch(err){
      console.error(err);
      buildStatus.textContent = "‚ùå " + (err?.message || "Impossible de g√©n√©rer.");
      alert("Erreur ‚ùå\n\n" + (err?.message || "Impossible de g√©n√©rer."));
    }finally{
      btnGenerate.disabled = false;
      btnGenerate.classList.remove("disabled");
    }
  };

  btnOpenPublic.onclick = (e)=>{
    e.preventDefault();
    if(currentScope === "general"){ alert("Choisis une √©tape."); return; }
    window.location.href = `../${currentScope}/programmation.html`;
  };

  schedCards.addEventListener("click", async (e)=>{
    const btn = e.target.closest("button[data-act]");
    if(!btn) return;
    if(currentScope === "general"){ alert("Choisis une √©tape."); return; }
    if(!currentProg){ alert("Pas de programmation."); return; }

    const act = btn.dataset.act;
    const slot = Number(btn.dataset.slot);

    try{
      schedStatus.textContent = "Traitement‚Ä¶";
      if(act === "up" && slot > 1) await swapSlots(currentScope, slot, slot-1);
      if(act === "down" && slot < scheduleRowCount) await swapSlots(currentScope, slot, slot+1);
    }catch(err){
      console.error(err);
      schedStatus.textContent = "‚ùå Erreur";
      alert("Erreur ‚ùå");
    }
  });

  // Logout
  document.getElementById("btnLogout").onclick = async (e)=>{
    e.preventDefault();
    await logout();
    window.location.href = "../index.html";
  };

  function showDenied(){
    accessDenied.style.display = "block";
    adminUI.style.display = "none";
    panelNeedStep.style.display = "none";
    panelBuild.style.display = "none";
    panelSchedule.style.display = "none";
    stopListeners();
  }

  function showAdmin(){
    accessDenied.style.display = "none";
    adminUI.style.display = "block";

    scopeEl.value = currentScope;
    setTabs(currentScope);
    showPanelsForScope(currentScope);

    scopeEl.onchange = ()=>{
      currentScope = scopeEl.value || "general";
      setTabs(currentScope);
      showPanelsForScope(currentScope);
    };
  }

  // Guard
  const g = await requireRole(["admin"]);
  if(!g.ok){ showDenied(); }
  else { showAdmin(); }

  onAuthStateChanged(auth, async (user)=>{
    if(!user){ showDenied(); return; }
    const g2 = await requireRole(["admin"]);
    if(!g2.ok){ showDenied(); return; }
  });
</script>

</body>
</html>
