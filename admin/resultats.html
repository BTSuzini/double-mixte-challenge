<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin ‚Äî R√©sultats</title>
  <link rel="stylesheet" href="../assets/css/main.css?v=20260222" />
</head>
<body>

<header class="topbar">
  <div class="container">
    <div class="topbar-row">
      <div class="brand-logo">
        <img src="../assets/img/logo-suzini.png" alt="Logo Suzini">
      </div>

      <h1 class="brand-title">
        üèÅ R√©sultats (admin)<br>
        <span style="opacity:.95;font-weight:800;" id="pageSub">√âtape ‚Äî</span>
      </h1>

      <div class="brand-logo">
        <img src="../assets/img/logo-challenge.png" alt="Logo Challenge">
      </div>
    </div>

    <nav class="nav">
      <a href="../index.html">Accueil public</a>
      <a href="#" id="btnLogout">D√©connexion</a>
    </nav>
  </div>
</header>

<main class="container">

  <section class="card" id="accessDenied" style="display:none;">
    <h2 style="margin:0 0 8px;">‚õî Acc√®s refus√©</h2>
    <p class="muted" style="margin:0;">Cette page est r√©serv√©e aux administrateurs.</p>
  </section>

  <section class="card" id="adminUI" style="display:none;">
    <h2 style="margin:0 0 10px;">üéõÔ∏è Zone</h2>

    <div class="field">
      <label for="scope">Choisir</label>
      <select id="scope">
        <option value="general">G√©n√©ral</option>
        <option value="etape1">√âtape 1</option>
        <option value="etape2">√âtape 2</option>
        <option value="etape3">√âtape 3</option>
        <option value="etape4">√âtape 4</option>
        <option value="etape5">√âtape 5</option>
      </select>
    </div>

    <div class="grid" style="margin-top:10px;" id="tabs"></div>
    <p class="muted" id="hint" style="margin-top:10px;"></p>
  </section>

  <section class="card" id="panelNeedStep" style="display:none;">
    <h2 style="margin:0 0 8px;">‚ÑπÔ∏è Choisir une √©tape</h2>
    <p class="muted" style="margin:0;">
      S√©lectionne une <b>√âtape</b> dans ‚ÄúZone‚Äù pour g√©rer les r√©sultats.
    </p>
  </section>

  <section class="card" id="panelResults" style="display:none;">
    <h2 style="margin:0 0 10px;">üèÅ R√©sultats</h2>
    <p class="muted" id="statusText" style="margin:0;">Chargement‚Ä¶</p>

    <div class="grid" style="margin-top:12px;">
      <button class="btn" id="btnOpenPublic" style="font-weight:900; color:#111;">
        üëÄ Ouvrir la programmation (public)
      </button>
    </div>

    <p class="muted" style="margin-top:12px;">
      ‚úÖ Format score :
      <br>‚Ä¢ Sets 1 & 2 : <b>jeux</b> (0‚Äì5), l‚Äô√©quipe qui a le plus de jeux gagne le set
      <br>‚Ä¢ Set 3 (si 1‚Äì1) : <b>tie-break</b> en points (0‚Äì99)
      <br>Les <b>manches/jeux/points</b> sont calcul√©s et stock√©s pour le futur onglet classement.
    </p>

    <div id="matchCards" style="display:grid; gap:12px; margin-top:14px;"></div>
  </section>

</main>

<style>
  .match-list{ display:flex; flex-direction:column; gap:14px; }

  .match-card{
    border-radius:18px;
    border:2px solid rgba(0,0,0,.06);
    padding:14px;
    background:#fff;
    box-shadow:0 1px 0 rgba(0,0,0,.03);
  }
  .match-card.courtA{ background:#FFF6D6; border-color:rgba(255, 196, 0, .35); }
  .match-card.courtB{ background:#FFE6EA; border-color:rgba(255, 0, 60, .25); }

  .match-head{
    display:flex;
    align-items:center;
    gap:10px;
    min-width:0;
  }

  .m-time{
    font-size:13px;
    font-weight:900;
    white-space:nowrap;
    letter-spacing:.2px;
  }

  .m-court{
    font-size:13px;
    font-weight:400;
    font-style:italic;
    opacity:.95;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    min-width:0;
    flex:1;
  }

  .m-status{
    font-size:14px;
    font-weight:900;
    white-space:nowrap;
    opacity:.85;
  }

  .team-row{
    margin-top:10px;
    display:grid;
    grid-template-columns: 1fr 54px 54px 54px;
    align-items:center;
    gap:6px;
  }

  .team-block{ min-width:0; }
  .team-title{
    font-size:15px;
    font-weight:900;
    line-height:1.15;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .team-sub{
    margin-top:2px;
    font-size:13px;
    font-weight:800;
    opacity:.85;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  .ibox{
    width:54px;
    height:40px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.12);
    background:#fff;
    font-weight:900;
    font-size:16px;
    text-align:center;
    outline:none;
    font-variant-numeric: tabular-nums;
  }
  .ibox:focus{ box-shadow: 0 0 0 3px rgba(0,0,0,.06); }

  .vs-line{
    margin:10px 0 6px;
    text-align:center;
    font-weight:900;
    letter-spacing:2px;
    opacity:.55;
    font-size:12px;
  }

  .btnsave{
    width:100%;
    margin-top:12px;
    padding:11px 12px;
    border-radius:14px;
    border:1px solid rgba(0,0,0,.12);
    background:#fff;
    cursor:pointer;
    font-weight:1000;
  }
  .btnsave:hover{ background:rgba(255,255,255,.85); }
  .btnsave:disabled{ opacity:.6; cursor:not-allowed; }

  .muted-mini{
    margin-top:8px;
    font-size:12px;
    opacity:.75;
    line-height:1.3;
  }

  .errline{
    margin-top:8px;
    font-size:12px;
    font-weight:900;
    color:#b00020;
    display:none;
  }

  @media (max-width: 420px){
    .team-row{ grid-template-columns: 1fr 52px 52px 52px; }
    .ibox{ width:52px; height:40px; }
  }

  @media (max-width: 380px){
    .m-time{ font-size:13px; }
    .m-court{ font-size:13px; }
    .team-title{ font-size:14px; }
    .team-sub{ font-size:12px; }
    .ibox{ width:50px; }
  }
</style>

<script type="module">
  import { auth, db } from "../assets/js/firebase.js";
  import { logout, requireRole } from "../assets/js/session.js";

  import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
  import {
    doc, onSnapshot, collection, setDoc,
    serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  const params = new URLSearchParams(location.search);
  const scopeFromUrl = params.get("scope") || "etape1";

  const accessDenied = document.getElementById("accessDenied");
  const adminUI = document.getElementById("adminUI");

  const scopeEl = document.getElementById("scope");
  const tabsEl  = document.getElementById("tabs");
  const hintEl  = document.getElementById("hint");
  const pageSub = document.getElementById("pageSub");

  const panelNeedStep = document.getElementById("panelNeedStep");
  const panelResults  = document.getElementById("panelResults");
  const statusText    = document.getElementById("statusText");
  const matchCards    = document.getElementById("matchCards");
  const btnOpenPublic = document.getElementById("btnOpenPublic");

  let currentScope = scopeFromUrl;
  let currentProg = null;
  let resultsByMatch = new Map();
  let unsubProg = null;
  let unsubRes = null;

  function stepLabel(scope){
    if(!scope || scope === "general") return "G√©n√©ral";
    const n = scope.replace("etape","");
    return `√âtape ${n}`;
  }

  function esc(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function setTabs(scope){
    tabsEl.innerHTML = "";

    if(scope === "general"){
      hintEl.textContent = "Zone G√©n√©ral : se g√®re depuis admin/index.html (infos).";
      const a = document.createElement("a");
      a.className = "btn";
      a.href = "index.html";
      a.textContent = "üì∞ Aller aux infos (G√©n√©ral)";
      tabsEl.appendChild(a);
      return;
    }

    hintEl.textContent = "Zone √âtape : √©quipes / inscriptions / tirage / programmation / r√©sultats.";

    const links = [
      ["üë• √âquipes", "equipes.html"],
      ["üìù Inscriptions", "inscriptions.html"],
      ["üé≤ Tirage", "tirage.html"],
      ["üìÖ Programmation", "programmation.html"],
      ["üèÅ R√©sultats", "resultats.html"],
    ];

    for(const [label, url] of links){
      const a = document.createElement("a");
      a.className = "btn";
      a.href = `${url}?scope=${encodeURIComponent(scope)}`;
      a.textContent = label;
      if(url === "resultats.html") a.style.fontWeight = "900";
      tabsEl.appendChild(a);
    }
  }

  function stopListeners(){
    if(unsubProg){ unsubProg(); unsubProg = null; }
    if(unsubRes){ unsubRes(); unsubRes = null; }
  }

  function showPanelsForScope(scope){
    pageSub.textContent = scope === "general" ? "G√©n√©ral" : `${stepLabel(scope)} ‚Äî BT250`;

    if(scope === "general"){
      panelNeedStep.style.display = "block";
      panelResults.style.display = "none";
      stopListeners();
      return;
    }

    panelNeedStep.style.display = "none";
    panelResults.style.display = "block";

    startProgListener(scope);
    startResultsListener(scope);
  }

  function progRef(scope){ return doc(db, "programmations", scope); }
  function resultsCol(scope){ return collection(db, `resultats_${scope}`); }

  function normalizeScheduleEntry(entry, slotObj){
    if(typeof entry === "number"){
      const slot = Number(entry);
      const court = slotObj?.court || (slot % 2 === 1 ? "A" : "B");
      return { slot, court };
    }
    if(entry && typeof entry === "object"){
      const slot = Number(entry.slot);
      const court = entry.court || slotObj?.court || (slot % 2 === 1 ? "A" : "B");
      return { slot, court };
    }
    const fallbackSlot = Number(slotObj?.slot || 1);
    return { slot: fallbackSlot, court: slotObj?.court || "A" };
  }

  function resolveTeamRef(ref){
    if(!currentProg) return null;

    const teams = currentProg.teams || {};
    const matches = currentProg.matches || {};

    if(!ref) return null;

    if(ref.type === "team"){
      return teams[ref.key] || null;
    }

    if(ref.type === "winner" || ref.type === "loser"){
      const mid = ref.matchId;
      const m = matches[mid];
      if(!m) return null;

      const res = resultsByMatch.get(mid);
      if(!res || (res.winnerSide !== "A" && res.winnerSide !== "B")) return null;

      const teamA = resolveTeamRef(m.A);
      const teamB = resolveTeamRef(m.B);

      const winner = (res.winnerSide === "A") ? teamA : teamB;
      const loser  = (res.winnerSide === "A") ? teamB : teamA;

      return ref.type === "winner" ? winner : loser;
    }

    return null;
  }

  function toIntOrNull(v){
    if(v === "" || v === null || typeof v === "undefined") return null;
    const n = Number(v);
    if(!Number.isFinite(n)) return null;
    if(!Number.isInteger(n)) return null;
    return n;
  }

  function clampRange(n, min, max){
    if(n === null) return null;
    if(n < min || n > max) return null;
    return n;
  }

  function setWinnerFromSetGames(a, b){
    if(a === null || b === null) return null;
    if(a === b) return null;
    return (a > b) ? "A" : "B";
  }

  function computeOutcome(inputs){
    const s1A = clampRange(inputs.s1A, 0, 5);
    const s1B = clampRange(inputs.s1B, 0, 5);
    const s2A = clampRange(inputs.s2A, 0, 5);
    const s2B = clampRange(inputs.s2B, 0, 5);
    const s3A = clampRange(inputs.s3A, 0, 99);
    const s3B = clampRange(inputs.s3B, 0, 99);

    const errs = [];

    function paired(a,b,label){
      const filledA = (a !== null);
      const filledB = (b !== null);
      if(filledA !== filledB){
        errs.push(`${label} : renseigner les 2 scores.`);
      }
    }
    paired(s1A,s1B,"Set 1");
    paired(s2A,s2B,"Set 2");
    paired(s3A,s3B,"Set 3 (TB)");

    const w1 = setWinnerFromSetGames(s1A,s1B);
    if(s1A !== null && s1B !== null && !w1) errs.push("Set 1 : √©galit√© impossible.");
    const w2 = setWinnerFromSetGames(s2A,s2B);
    if(s2A !== null && s2B !== null && !w2) errs.push("Set 2 : √©galit√© impossible.");

    let setsA = 0, setsB = 0;
    if(w1 === "A") setsA++; else if(w1 === "B") setsB++;
    if(w2 === "A") setsA++; else if(w2 === "B") setsB++;

    const needTB = (w1 && w2 && setsA === 1 && setsB === 1);

    if(w1 && w2 && (setsA === 2 || setsB === 2)){
      if(s3A !== null || s3B !== null) errs.push("Set 3 : √† laisser vide (match gagn√© en 2 sets).");
    }

    if(needTB && s3A !== null && s3B !== null){
      if(s3A === s3B) errs.push("Set 3 : √©galit√© impossible.");
      const w3 = (s3A > s3B) ? "A" : "B";
      if(w3 === "A") setsA++; else setsB++;
    }

    const complete = (setsA === 2 || setsB === 2);

    const gamesA = (s1A ?? 0) + (s2A ?? 0);
    const gamesB = (s1B ?? 0) + (s2B ?? 0);

    const tbA = (needTB && s3A !== null) ? s3A : 0;
    const tbB = (needTB && s3B !== null) ? s3B : 0;

    function fmtPart(x){ return (x === null) ? "‚Äî" : String(x); }
    const scoreA = `${fmtPart(s1A)} / ${fmtPart(s2A)}${needTB ? " / " + fmtPart(s3A) : ""}`;
    const scoreB = `${fmtPart(s1B)} / ${fmtPart(s2B)}${needTB ? " / " + fmtPart(s3B) : ""}`;

    let score = "";
    if(s1A !== null && s1B !== null) score += `${s1A}-${s1B}`;
    if(s2A !== null && s2B !== null) score += (score ? " " : "") + `${s2A}-${s2B}`;
    if(needTB && s3A !== null && s3B !== null) score += (score ? " " : "") + `${s3A}-${s3B}`;

    const winnerSide = complete ? (setsA > setsB ? "A" : "B") : null;

    if(complete && !(w1 && w2)) errs.push("Impossible de valider : renseigner Set 1 et Set 2.");

    if(inputs.s1A !== null && s1A === null) errs.push("Set 1A : valeur invalide (0‚Äì5).");
    if(inputs.s1B !== null && s1B === null) errs.push("Set 1B : valeur invalide (0‚Äì5).");
    if(inputs.s2A !== null && s2A === null) errs.push("Set 2A : valeur invalide (0‚Äì5).");
    if(inputs.s2B !== null && s2B === null) errs.push("Set 2B : valeur invalide (0‚Äì5).");
    if(inputs.s3A !== null && s3A === null) errs.push("Set 3A : valeur invalide (0‚Äì99).");
    if(inputs.s3B !== null && s3B === null) errs.push("Set 3B : valeur invalide (0‚Äì99).");

    return {
      ok: errs.length === 0,
      errs,
      needTB,
      complete,
      winnerSide,
      setsA, setsB,
      gamesA, gamesB,
      tbA, tbB,
      s1A, s1B, s2A, s2B, s3A, s3B,
      scoreA, scoreB,
      score
    };
  }

  function showErr(mid, msgs){
    const el = document.getElementById(`err-${mid}`);
    if(!el) return;
    if(!msgs || msgs.length === 0){
      el.style.display = "none";
      el.textContent = "";
      return;
    }
    el.style.display = "block";
    el.textContent = "‚ùå " + msgs.join(" ‚Äî ");
  }

  function readInputsFor(mid){
    const card = matchCards.querySelector(`.match-card[data-mid="${CSS.escape(mid)}"]`);
    if(!card) return { s1A:null,s1B:null,s2A:null,s2B:null,s3A:null,s3B:null };

    const get = (k)=>{
      const el = card.querySelector(`input.ibox[data-k="${CSS.escape(k)}"]`);
      return el ? el.value : "";
    };

    return {
      s1A: toIntOrNull(get("s1A")),
      s1B: toIntOrNull(get("s1B")),
      s2A: toIntOrNull(get("s2A")),
      s2B: toIntOrNull(get("s2B")),
      s3A: toIntOrNull(get("s3A")),
      s3B: toIntOrNull(get("s3B")),
    };
  }

  async function saveResult(mid){
    const raw = readInputsFor(mid);
    const out = computeOutcome(raw);

    if(!out.ok){
      showErr(mid, out.errs);
      return;
    }
    showErr(mid, []);

    const userEmail = auth.currentUser?.email || null;

    const payload = {
      matchId: mid,

      s1A: out.s1A, s1B: out.s1B,
      s2A: out.s2A, s2B: out.s2B,
      s3A: out.needTB ? out.s3A : null,
      s3B: out.needTB ? out.s3B : null,

      setsA: out.setsA,
      setsB: out.setsB,
      gamesA: out.gamesA,
      gamesB: out.gamesB,
      tbA: out.tbA,
      tbB: out.tbB,

      winnerSide: out.winnerSide,
      scoreA: out.scoreA,
      scoreB: out.scoreB,
      score: out.score,

      updatedAt: serverTimestamp(),
      validatedBy: userEmail
    };

    await setDoc(doc(db, `resultats_${currentScope}`, mid), payload, { merge:true });
  }

  function teamPartsFromTeam(t){
    if(!t) return { title:"‚Äî", sub:"" };
    return {
      title: t.teamName || "√âquipe",
      sub: `${t.p1FirstName || "?"} / ${t.p2FirstName || "?"}`
    };
  }

  function teamRefPartsForMatchSide(sideRef){
    const t = resolveTeamRef(sideRef);
    if(t) return teamPartsFromTeam(t);

    if(!sideRef) return { title:"‚Äî", sub:"" };
    if(sideRef.type === "team") return { title: sideRef.key, sub:"" };
    if(sideRef.type === "winner") return { title: `V${sideRef.matchId.slice(1)}`, sub:"" };
    if(sideRef.type === "loser")  return { title: `P${sideRef.matchId.slice(1)}`, sub:"" };
    return { title:"‚Äî", sub:"" };
  }

  function courtLabel(courtKey){
    const c = currentProg?.courts || {};
    const name = c[courtKey] || (courtKey || "‚Äî");
    const emo = (courtKey === "A") ? "üêù" : (courtKey === "B" ? "üå∂Ô∏è" : "üéæ");
    return `${emo} ${name} ${emo}`;
  }

  function courtClass(courtKey){
    return (courtKey === "A") ? "courtA" : (courtKey === "B" ? "courtB" : "");
  }

  function renderAll(){
    if(!currentProg){
      matchCards.innerHTML = "";
      statusText.textContent = "‚è≥ Programmation non disponible (g√©n√®re-la d‚Äôabord).";
      return;
    }

    const matches = currentProg.matches || {};
    const slots = Array.isArray(currentProg.slots) ? currentProg.slots : [];
    const schedule = currentProg.schedule || {};

    // slot -> mid
    const slotToMatch = new Map();
    for(const [mid, entry] of Object.entries(schedule)){
      const slotNum = (typeof entry === "number") ? Number(entry) : Number(entry?.slot);
      if(!slotToMatch.has(slotNum)){
        slotToMatch.set(slotNum, mid);
      }
    }

    const cards = [];
    for(const s of slots){
      const mid = slotToMatch.get(Number(s.slot));
      const m = mid ? matches[mid] : null;
      if(!m) continue;

      const entry = schedule[mid];
      const norm = normalizeScheduleEntry(entry, s);
      const courtKey = norm.court;

      const a = teamRefPartsForMatchSide(m.A);
      const b = teamRefPartsForMatchSide(m.B);

      const stored = resultsByMatch.get(mid) || {};
      const done = (stored.winnerSide === "A" || stored.winnerSide === "B");

      const v = {
        s1A: (stored.s1A ?? "") === null ? "" : String(stored.s1A ?? ""),
        s1B: (stored.s1B ?? "") === null ? "" : String(stored.s1B ?? ""),
        s2A: (stored.s2A ?? "") === null ? "" : String(stored.s2A ?? ""),
        s2B: (stored.s2B ?? "") === null ? "" : String(stored.s2B ?? ""),
        s3A: (stored.s3A ?? "") === null ? "" : String(stored.s3A ?? ""),
        s3B: (stored.s3B ?? "") === null ? "" : String(stored.s3B ?? ""),
      };

      cards.push(`
        <div class="match-card ${esc(courtClass(courtKey))}" data-mid="${esc(mid)}">
          <div class="match-head">
            <div class="m-time">${esc(s.time)}</div>
            <div class="m-court">${esc(courtLabel(courtKey))}</div>
            <div class="m-status">${done ? "‚úÖ" : "‚è≥"}</div>
          </div>

          ${s.note ? `<div class="muted-mini">‚ö†Ô∏è ${esc(s.note)}</div>` : ""}

          <div class="team-row">
            <div class="team-block">
              <div class="team-title">${esc(a.title)}</div>
              ${a.sub ? `<div class="team-sub">${esc(a.sub)}</div>` : ``}
            </div>

            <input class="ibox" inputmode="numeric" pattern="[0-9]*" maxlength="2"
              data-mid="${esc(mid)}" data-k="s1A" value="${esc(v.s1A)}">

            <input class="ibox" inputmode="numeric" pattern="[0-9]*" maxlength="2"
              data-mid="${esc(mid)}" data-k="s2A" value="${esc(v.s2A)}">

            <input class="ibox" inputmode="numeric" pattern="[0-9]*" maxlength="2"
              data-mid="${esc(mid)}" data-k="s3A" value="${esc(v.s3A)}">
          </div>

          <div class="vs-line">VS</div>

          <div class="team-row">
            <div class="team-block">
              <div class="team-title">${esc(b.title)}</div>
              ${b.sub ? `<div class="team-sub">${esc(b.sub)}</div>` : ``}
            </div>

            <input class="ibox" inputmode="numeric" pattern="[0-9]*" maxlength="2"
              data-mid="${esc(mid)}" data-k="s1B" value="${esc(v.s1B)}">

            <input class="ibox" inputmode="numeric" pattern="[0-9]*" maxlength="2"
              data-mid="${esc(mid)}" data-k="s2B" value="${esc(v.s2B)}">

            <input class="ibox" inputmode="numeric" pattern="[0-9]*" maxlength="2"
              data-mid="${esc(mid)}" data-k="s3B" value="${esc(v.s3B)}">
          </div>

          <button class="btnsave" data-act="save" data-mid="${esc(mid)}">
            ${done ? "‚úÖ Mettre √† jour" : "üíæ Enregistrer / Valider"}
          </button>

          <div class="muted-mini">
            <b>Derni√®re maj :</b>
            ${stored.updatedAt?.toDate ? esc(stored.updatedAt.toDate().toLocaleString()) : "‚Äî"}
          </div>

          <div class="errline" id="err-${esc(mid)}"></div>
        </div>
      `);
    }

    matchCards.innerHTML = cards.join("") || `<div class="muted">Aucun match.</div>`;
    statusText.textContent = "‚úÖ OK (modif possible m√™me apr√®s validation).";
  }

  function startProgListener(scope){
    if(unsubProg){ unsubProg(); unsubProg = null; }
    unsubProg = onSnapshot(progRef(scope), (snap)=>{
      currentProg = snap.exists() ? (snap.data() || {}) : null;
      renderAll();
    }, (err)=>{
      console.error(err);
      statusText.textContent = "üî¥ Erreur programmation.";
    });
  }

  function startResultsListener(scope){
    if(unsubRes){ unsubRes(); unsubRes = null; }
    unsubRes = onSnapshot(resultsCol(scope), (snap)=>{
      resultsByMatch = new Map();
      snap.forEach(d=> resultsByMatch.set(d.id, d.data() || {}));
      renderAll();
    });
  }

  // ‚úÖ auto-advance (option 3)
  const INPUT_ORDER = ["s1A","s2A","s3A","s1B","s2B","s3B"];

  function focusNextInput(currentInput){
    const card = currentInput.closest(".match-card");
    if(!card) return;
    const k = currentInput.dataset.k;
    const idx = INPUT_ORDER.indexOf(k);
    if(idx < 0) return;
    const nextK = INPUT_ORDER[idx + 1];
    if(!nextK) return;
    const next = card.querySelector(`input.ibox[data-k="${CSS.escape(nextK)}"]`);
    if(next){ next.focus(); next.select?.(); }
  }

  function focusPrevInput(currentInput){
    const card = currentInput.closest(".match-card");
    if(!card) return;
    const k = currentInput.dataset.k;
    const idx = INPUT_ORDER.indexOf(k);
    if(idx <= 0) return;
    const prevK = INPUT_ORDER[idx - 1];
    const prev = card.querySelector(`input.ibox[data-k="${CSS.escape(prevK)}"]`);
    if(prev){ prev.focus(); prev.select?.(); }
  }

  matchCards.addEventListener("input", (e)=>{
    const el = e.target;
    if(!(el instanceof HTMLInputElement)) return;
    if(!el.classList.contains("ibox")) return;

    el.value = el.value.replace(/[^\d]/g, "");
    const max = Number(el.getAttribute("maxlength") || "0");
    if(max > 0 && el.value.length >= max) focusNextInput(el);
  });

  matchCards.addEventListener("keydown", (e)=>{
    const el = e.target;
    if(!(el instanceof HTMLInputElement)) return;
    if(!el.classList.contains("ibox")) return;

    if(e.key === "Backspace" && (el.value === "" || el.value.length === 0)){
      e.preventDefault();
      focusPrevInput(el);
    }
  });

  function showDenied(){
    accessDenied.style.display = "block";
    adminUI.style.display = "none";
    panelNeedStep.style.display = "none";
    panelResults.style.display = "none";
    stopListeners();
  }

  function showAdmin(){
    accessDenied.style.display = "none";
    adminUI.style.display = "block";

    scopeEl.value = currentScope;
    setTabs(currentScope);
    showPanelsForScope(currentScope);

    scopeEl.onchange = ()=>{
      currentScope = scopeEl.value || "general";
      setTabs(currentScope);
      showPanelsForScope(currentScope);
    };
  }

  btnOpenPublic.onclick = (e)=>{
    e.preventDefault();
    if(currentScope === "general"){ alert("Choisis une √©tape."); return; }
    window.location.href = `../${currentScope}/programmation.html`;
  };

  matchCards.addEventListener("click", async (e)=>{
    const btn = e.target.closest("button[data-act='save']");
    if(!btn) return;

    const mid = btn.dataset.mid;
    if(!mid) return;

    btn.disabled = true;
    try{
      await saveResult(mid);
    }catch(err){
      console.error(err);
      alert("Erreur Firestore ‚ùå");
    }finally{
      btn.disabled = false;
    }
  });

  document.getElementById("btnLogout").onclick = async (e)=>{
    e.preventDefault();
    await logout();
    window.location.href = "../index.html";
  };

  const g = await requireRole(["admin"]);
  if(!g.ok){ showDenied(); }
  else { showAdmin(); }

  onAuthStateChanged(auth, async (user)=>{
    if(!user){ showDenied(); return; }
    const g2 = await requireRole(["admin"]);
    if(!g2.ok){ showDenied(); return; }
  });
</script>

</body>
</html>
