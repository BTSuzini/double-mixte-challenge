<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin â€” RÃ©sultats</title>
  <link rel="stylesheet" href="../assets/css/main.css?v=20260225-admin-resultats" />

  <style>
    /* âœ… Onglet actif = gris clair (tabs Zone) */
    .btn.is-active{
      background:#f1f1f1 !important;
      border-color:#d7d7d7 !important;
      color:#111 !important;
      box-shadow: 0 10px 22px rgba(0,0,0,.10);
    }

    .match-list{ display:flex; flex-direction:column; gap:14px; }

    .match-card{
      border-radius:18px;
      border:2px solid rgba(0,0,0,.06);
      padding:14px;
      background:#fff;
      box-shadow:0 1px 0 rgba(0,0,0,.03);
    }
    .match-card.courtA{ background:#FFF6D6; border-color:rgba(255, 196, 0, .35); }
    .match-card.courtB{ background:#FFE6EA; border-color:rgba(255, 0, 60, .25); }

    .match-head{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .m-slot{
      font-size:12px;
      font-weight:900;
      opacity:.7;
      white-space:nowrap;
    }
    .m-time{
      font-size:13px;
      font-weight:900;
      white-space:nowrap;
      letter-spacing:.2px;
    }
    .m-court{
      font-size:13px;
      font-weight:400;
      font-style:italic;
      opacity:.95;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      min-width:0;
      flex:1;
    }

    .row{
      margin-top:10px;
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
      min-width:0;
    }

    .team{
      min-width:0;
    }
    .team-title{
      font-size:15px;
      font-weight:1000;
      line-height:1.15;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .team-sub{
      margin-top:2px;
      font-size:13px;
      font-weight:800;
      opacity:.85;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .scoreline{
      display:flex;
      gap:6px;
      align-items:center;
      flex: 0 0 auto;
      white-space:nowrap;
    }
    .sc{
      width:44px;
      height:38px;
      border-radius:12px;
      border:1px solid #ddd;
      background:#fff;
      font-weight:1000;
      text-align:center;
      outline:none;
      font-variant-numeric: tabular-nums;
    }
    .dash{ opacity:.55; font-weight:900; }

    .actions{
      margin-top:12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .left-actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .mini{
      font-size:12px;
      font-weight:900;
      opacity:.75;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid #eee;
      background:#fafafa;
      font-weight:1000;
      white-space:nowrap;
    }
    .dot{
      width:10px; height:10px;
      border-radius:999px;
      display:inline-block;
      background:#bbb;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.12);
    }
    .dot.red{ background:#e74c3c; }
    .dot.orange{ background:#f39c12; }
    .dot.green{ background:#2ecc71; }

    .warn{
      border:1px solid rgba(176,0,32,.25);
      background:rgba(176,0,32,.06);
      padding:10px 12px;
      border-radius:14px;
      font-weight:900;
      margin-top:10px;
    }

    @media (max-width: 380px){
      .team-title{ font-size:14px; }
      .team-sub{ font-size:12px; }
      .sc{ width:42px; height:36px; }
    }
  </style>
</head>

<body>

<header class="topbar">
  <div class="container">
    <div class="topbar-row">
      <div class="brand-logo">
        <img src="../assets/img/logo-suzini.png" alt="Logo Suzini">
      </div>

      <div class="brand-title" style="display:flex;align-items:center;justify-content:center;">
        <img src="../assets/img/etape1-rouge.png"
             alt="Suzini Beach Tennis Double Mixte Challenge"
             style="width:min(560px, 100%);max-height:90px;height:auto;object-fit:contain;display:block;filter:drop-shadow(0 1px 0 rgba(0,0,0,.15));">
      </div>

      <div class="brand-logo">
        <img src="../assets/img/logo-challenge.png" alt="Logo Challenge">
      </div>
    </div>

    <nav class="nav">
      <a href="../index.html">ğŸ  Accueil public</a>
      <a href="#" id="btnLogout">ğŸšª DÃ©connexion</a>
    </nav>
  </div>
</header>

<main class="container">

  <section class="card" id="accessDenied" style="display:none;">
    <h2 style="margin:0 0 8px;">â›” AccÃ¨s refusÃ©</h2>
    <p class="muted" style="margin:0;">Cette page est rÃ©servÃ©e aux administrateurs.</p>
  </section>

  <!-- âœ… Zone -->
  <section class="card" id="adminZone" style="display:none;">
    <h2 style="margin:0 0 10px;">ğŸ§­ Zone</h2>

    <div class="field">
      <label for="scope">Choisir</label>
      <select id="scope">
        <option value="general">ğŸŒ GÃ©nÃ©ral</option>
        <option value="etape1">ğŸ¾ Ã‰tape 1</option>
        <option value="etape2">ğŸ¾ Ã‰tape 2</option>
        <option value="etape3">ğŸ¾ Ã‰tape 3</option>
        <option value="etape4">ğŸ¾ Ã‰tape 4</option>
        <option value="etape5">ğŸ§ª Ã‰tape 5 (test)</option>
      </select>
    </div>

    <div class="grid" style="margin-top:10px;" id="tabs"></div>
    <p class="muted" id="hint" style="margin-top:10px; display:none;"></p>
  </section>

  <section class="card" id="panelNeedStep" style="display:none;">
    <h2 style="margin:0 0 8px;">â„¹ï¸ Choisir une Ã©tape</h2>
    <p class="muted" style="margin:0;">
      SÃ©lectionne une <b>Ã‰tape</b> dans â€œZoneâ€ pour saisir les rÃ©sultats.
      <br>(Le <b>GÃ©nÃ©ral</b> se gÃ¨re depuis <b>admin/index.html</b>.)
    </p>
  </section>

  <!-- RÃ©sultats -->
  <section class="card" id="panelResults" style="display:none;">
    <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:flex-end; justify-content:space-between;">
      <div>
        <h2 style="margin:0 0 6px;">ğŸ RÃ©sultats</h2>
        <p class="muted" id="statusText" style="margin:0;">Chargementâ€¦</p>
      </div>

      <a class="btn" id="btnOpenPublic" href="#" style="font-weight:900; color:#111; text-align:center;">
        ğŸ‘€ Ouvrir la page RÃ©sultats (public)
      </a>
    </div>

    <div id="warningBox" class="warn" style="display:none;"></div>

    <div id="adminList" style="margin-top:12px;"></div>

    <p class="muted" style="margin-top:10px;">
      ğŸ’¡ Saisie : 2 sets gagnants = rÃ©sultat validÃ© automatiquement (winnerSide A/B).
      Les cases vides = â€œnon jouÃ©â€.
    </p>
  </section>

</main>

<script type="module">
  import { auth, db } from "../assets/js/firebase.js";
  import { logout, requireRole } from "../assets/js/session.js";
  import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
  import {
    doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp, collection
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  const LS_SCOPE_KEY = "admin_scope_last";

  // ---- scope (URL ?scope=etape1) + fallback localStorage
  const params = new URLSearchParams(location.search);
  const scopeFromUrl = params.get("scope");

  function getInitialScope(){
    if(scopeFromUrl) return scopeFromUrl;
    try{
      const saved = localStorage.getItem(LS_SCOPE_KEY);
      if(saved) return saved;
    }catch(e){}
    return "etape1";
  }
  function persistScope(scope){
    try{ localStorage.setItem(LS_SCOPE_KEY, scope); }catch(e){}
  }

  // ---- DOM
  const accessDenied = document.getElementById("accessDenied");
  const adminZone = document.getElementById("adminZone");
  const scopeEl = document.getElementById("scope");
  const tabsEl  = document.getElementById("tabs");

  const panelNeedStep = document.getElementById("panelNeedStep");
  const panelResults = document.getElementById("panelResults");

  const statusText = document.getElementById("statusText");
  const warningBox = document.getElementById("warningBox");
  const adminList  = document.getElementById("adminList");
  const btnOpenPublic = document.getElementById("btnOpenPublic");

  // ---- state
  let currentScope = getInitialScope();
  let unsubProg = null;
  let unsubRes  = null;

  let currentProg = null;
  let resultsByMatch = new Map(); // matchId -> result doc

  function esc(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function makeDisabledBtn(label, reason){
    const a = document.createElement("a");
    a.className = "btn disabled";
    a.href = "#";
    a.setAttribute("aria-disabled","true");
    a.textContent = label;
    a.onclick = (e)=>{ e.preventDefault(); alert(reason); };
    return a;
  }

  function setTabs(scope){
    tabsEl.innerHTML = "";

    if(scope === "general"){
      const a = document.createElement("a");
      a.className = "btn";
      a.href = "index.html";
      a.textContent = "ğŸ“° Aller Ã  Admin â€” GÃ©nÃ©ral";
      tabsEl.appendChild(a);
      return;
    }

    if(scope === "etape5"){
      tabsEl.appendChild(makeDisabledBtn("ğŸ½ï¸ Repas (plus tard)", "Repas non activÃ© pour lâ€™Ã©tape 5 (zone test)."));
    }

    const links = [
      ["ğŸ‘¥ Ã‰quipes",        "equipes.html"],
      ["ğŸ“ Inscriptions",   "inscriptions.html"],
      ...(scope !== "etape5" ? [["ğŸ½ï¸ Repas", "repas.html"]] : []),
      ["ğŸ² Tirage",         "tirage.html"],
      ["ğŸ“… Programmation",  "programmation.html"],
      ["ğŸ RÃ©sultats",      "resultats.html"],
      ["ğŸ† Classement",     "classement.html"],
    ];

    for(const [label, url] of links){
      const a = document.createElement("a");
      a.className = "btn";
      a.href = `${url}?scope=${encodeURIComponent(scope)}`;
      a.textContent = label;

      if(url === "resultats.html"){
        a.classList.add("is-active"); // âœ… actif gris clair
      }
      tabsEl.appendChild(a);
    }
  }

  function stopListeners(){
    if(unsubProg){ unsubProg(); unsubProg = null; }
    if(unsubRes){ unsubRes(); unsubRes = null; }
    currentProg = null;
    resultsByMatch = new Map();
  }

  // ---- Firestore refs
  function progRef(scope){ return doc(db, "programmations", scope); }
  function resultsCol(scope){ return collection(db, `resultats_${scope}`); }

  // ---- Helpers teams display (compatible avec refs winner/loser)
  function teamPartsFromTeam(t){
    if(!t) return { title:"â€”", sub:"" };
    const title = t.teamName || "Ã‰quipe";
    const sub = `${t.p1FirstName || "?"} / ${t.p2FirstName || "?"}`;
    return { title, sub };
  }

  function normalizeWinnerSide(x){
    return (x === "A" || x === "B") ? x : null;
  }

  function resolveTeamRef(ref){
    if(!currentProg) return null;

    const teams = currentProg.teams || {};
    const matches = currentProg.matches || {};

    if(!ref) return null;

    if(ref.type === "team"){
      return teams[ref.key] || null;
    }

    if(ref.type === "winner" || ref.type === "loser"){
      const mid = ref.matchId;
      const m = matches[mid];
      if(!m) return null;

      const res = resultsByMatch.get(mid);
      const w = normalizeWinnerSide(res?.winnerSide);
      if(!w) return null;

      const teamA = resolveTeamRef(m.A);
      const teamB = resolveTeamRef(m.B);
      if(!teamA || !teamB) return null;

      const winner = (w === "A") ? teamA : teamB;
      const loser  = (w === "A") ? teamB : teamA;

      return ref.type === "winner" ? winner : loser;
    }

    return null;
  }

  function teamRefParts(ref){
    if(!ref) return { title:"â€”", sub:"" };

    if(ref.type === "team"){
      const t = resolveTeamRef(ref);
      return t ? teamPartsFromTeam(t) : { title: ref.key || "â€”", sub:"" };
    }
    if(ref.type === "winner") return { title: `V${String(ref.matchId || "").slice(1)}`, sub:"" };
    if(ref.type === "loser")  return { title: `P${String(ref.matchId || "").slice(1)}`, sub:"" };
    return { title:"â€”", sub:"" };
  }

  // ---- score / winner calc
  function toInt(v){
    if(v === null || v === undefined) return null;
    const s = String(v).trim();
    if(!s) return null;
    const n = Number(s.replace(",", "."));
    if(!Number.isFinite(n)) return null;
    // scores must be integers (0-99)
    const i = Math.round(n);
    if(String(i) !== String(n) && !Number.isInteger(n)) return null;
    if(i < 0 || i > 99) return null;
    return i;
  }

  function calcWinnerSide(s){
    // s = {s1A,s1B,s2A,s2B,s3A,s3B} numbers or null
    const sets = [
      [s.s1A, s.s1B],
      [s.s2A, s.s2B],
      [s.s3A, s.s3B],
    ];

    let aWon = 0, bWon = 0;
    for(const [a,b] of sets){
      const A = toInt(a), B = toInt(b);
      if(A === null || B === null) continue; // set not complete
      if(A === B) continue; // ignore invalid ties
      if(A > B) aWon++;
      else bWon++;
    }
    if(aWon >= 2 && aWon > bWon) return "A";
    if(bWon >= 2 && bWon > aWon) return "B";
    return null;
  }

  function dotClass(winnerSide){
    if(winnerSide === "A" || winnerSide === "B") return "green";
    // if some scores entered but not decided => orange
    return "red";
  }

  function statusLabel(stored){
    const w = normalizeWinnerSide(stored?.winnerSide);
    if(w) return "ValidÃ©";
    const any =
      [stored?.s1A,stored?.s1B,stored?.s2A,stored?.s2B,stored?.s3A,stored?.s3B]
        .some(v => String(v ?? "").trim() !== "");
    return any ? "En cours" : "Non saisi";
  }

  // ---- rendering
  function courtLabel(prog, courtKey){
    const name = prog?.courts?.[courtKey] || courtKey || "â€”";
    const emo = (courtKey === "A") ? "ğŸ" : (courtKey === "B" ? "ğŸŒ¶ï¸" : "ğŸ¾");
    return `${emo} ${name} ${emo}`;
  }
  function courtClass(courtKey){
    return (courtKey === "A") ? "courtA" : (courtKey === "B" ? "courtB" : "");
  }

  function normalizeScheduleEntry(entry, slotObj){
    if(typeof entry === "number"){
      const slot = Number(entry);
      const court = slotObj?.court || (slot % 2 === 1 ? "A" : "B");
      return { slot, court };
    }
    if(entry && typeof entry === "object"){
      const slot = Number(entry.slot);
      const court = entry.court || slotObj?.court || (slot % 2 === 1 ? "A" : "B");
      return { slot, court };
    }
    const fallbackSlot = Number(slotObj?.slot || 1);
    return { slot: fallbackSlot, court: slotObj?.court || "A" };
  }

  function fmtUpdated(ts){
    try{
      const d = ts?.toDate ? ts.toDate() : null;
      if(!d) return "â€”";
      return d.toLocaleString("fr-FR", {
        year:"numeric", month:"2-digit", day:"2-digit",
        hour:"2-digit", minute:"2-digit"
      });
    }catch{ return "â€”"; }
  }

  function render(){
    warningBox.style.display = "none";
    warningBox.textContent = "";

    if(currentScope === "general"){
      statusText.textContent = "Choisis une Ã©tape.";
      adminList.innerHTML = "";
      return;
    }

    btnOpenPublic.href = `../${currentScope}/resultats.html`;

    if(!currentProg){
      statusText.textContent = "â„¹ï¸ Programmation introuvable. GÃ©nÃ¨re dâ€™abord la programmation.";
      adminList.innerHTML = "";
      warningBox.style.display = "block";
      warningBox.textContent = "âš ï¸ Pas de programmation : impossible dâ€™afficher les matchs. Va sur â€œProgrammationâ€ puis gÃ©nÃ¨re-la depuis le tirage VALIDÃ‰.";
      return;
    }

    const matches = currentProg.matches || {};
    const slots = Array.isArray(currentProg.slots) ? currentProg.slots : [];
    const schedule = currentProg.schedule || {};

    // map slot -> matchId
    const slotToMatch = new Map();
    for(const [mid, entry] of Object.entries(schedule)){
      const slotNum = (typeof entry === "number") ? Number(entry) : Number(entry?.slot);
      const sObj = slots.find(x => Number(x.slot) === slotNum) || null;
      const norm = normalizeScheduleEntry(entry, sObj);
      if(!slotToMatch.has(norm.slot)){
        slotToMatch.set(norm.slot, mid);
      }
    }

    // list in slot order
    const cards = [];
    let nOk=0, nTotal=0;

    for(const s of slots){
      const mid = slotToMatch.get(Number(s.slot));
      const m = mid ? matches[mid] : null;
      if(!m) continue;

      nTotal++;

      const a = teamRefParts(m.A);
      const b = teamRefParts(m.B);

      const entry = schedule[mid];
      const norm = normalizeScheduleEntry(entry, s);
      const courtKey = norm.court;

      const stored = resultsByMatch.get(mid) || {};
      const winnerSide = normalizeWinnerSide(stored?.winnerSide);
      if(winnerSide) nOk++;

      const badge = statusLabel(stored);
      const dot = dotClass(winnerSide);

      const meta = `DerniÃ¨re maj : ${esc(fmtUpdated(stored?.updatedAt))} Â· ${esc(stored?.updatedBy || "â€”")}`;

      cards.push(`
        <div class="match-card ${esc(courtClass(courtKey))}" data-mid="${esc(mid)}">
          <div class="match-head">
            <div class="m-slot">#${esc(s.slot)} Â· ${esc(mid)}</div>
            <div class="m-time">${esc(s.time || "â€”")}</div>
            <div class="m-court">${esc(courtLabel(currentProg, courtKey))}</div>
            <div class="pill" title="${esc(badge)}"><span class="dot ${dot}"></span>${esc(badge)}</div>
          </div>

          ${s.note ? `<div class="muted" style="margin-top:8px;">âš ï¸ ${esc(s.note)}</div>` : ""}

          <div class="row">
            <div class="team">
              <div class="team-title">${esc(a.title)}</div>
              ${a.sub ? `<div class="team-sub">${esc(a.sub)}</div>` : ``}
            </div>
            <div class="scoreline">
              <input class="sc" inputmode="numeric" pattern="[0-9]*" maxlength="2" placeholder="â€”" data-k="s1A" value="${esc(stored?.s1A ?? "")}">
              <span class="dash">-</span>
              <input class="sc" inputmode="numeric" pattern="[0-9]*" maxlength="2" placeholder="â€”" data-k="s1B" value="${esc(stored?.s1B ?? "")}">
              <span class="dash">|</span>
              <input class="sc" inputmode="numeric" pattern="[0-9]*" maxlength="2" placeholder="â€”" data-k="s2A" value="${esc(stored?.s2A ?? "")}">
              <span class="dash">-</span>
              <input class="sc" inputmode="numeric" pattern="[0-9]*" maxlength="2" placeholder="â€”" data-k="s2B" value="${esc(stored?.s2B ?? "")}">
              <span class="dash">|</span>
              <input class="sc" inputmode="numeric" pattern="[0-9]*" maxlength="2" placeholder="â€”" data-k="s3A" value="${esc(stored?.s3A ?? "")}">
              <span class="dash">-</span>
              <input class="sc" inputmode="numeric" pattern="[0-9]*" maxlength="2" placeholder="â€”" data-k="s3B" value="${esc(stored?.s3B ?? "")}">
            </div>
          </div>

          <div class="row" style="margin-top:10px;">
            <div class="team">
              <div class="team-title">${esc(b.title)}</div>
              ${b.sub ? `<div class="team-sub">${esc(b.sub)}</div>` : ``}
            </div>
            <div class="mini" style="text-align:right;">
              winnerSide: <b data-winner>${esc(winnerSide || "â€”")}</b>
            </div>
          </div>

          <div class="actions">
            <div class="left-actions">
              <button class="btn" data-act="save" style="font-weight:900; color:#111;">ğŸ’¾ Enregistrer</button>
              <button class="btn" data-act="clear" style="font-weight:900; color:#111; border-color:#f1b2b2;">ğŸ§½ Effacer</button>
            </div>
            <div class="mini muted">${meta}</div>
          </div>
        </div>
      `);
    }

    statusText.textContent = `ğŸŸ¢ En direct â€” ${nOk}/${nTotal} match(s) validÃ©(s)`;
    adminList.innerHTML = cards.length
      ? `<div class="match-list">${cards.join("")}</div>`
      : `<p class="muted">Aucun match.</p>`;
  }

  // ---- Firestore listeners
  function startProgListener(scope){
    if(unsubProg){ unsubProg(); unsubProg = null; }
    statusText.textContent = "Chargementâ€¦";
    adminList.innerHTML = "";

    unsubProg = onSnapshot(progRef(scope), (snap)=>{
      currentProg = snap.exists() ? (snap.data() || {}) : null;
      render();
    }, (err)=>{
      console.error(err);
      currentProg = null;
      statusText.textContent = "âŒ Erreur Firestore (programmation).";
      render();
    });
  }

  function startResultsListener(scope){
    if(unsubRes){ unsubRes(); unsubRes = null; }
    resultsByMatch = new Map();

    unsubRes = onSnapshot(resultsCol(scope), (snap)=>{
      resultsByMatch = new Map();
      snap.forEach(d => resultsByMatch.set(d.id, d.data() || {}));
      render();
    }, (err)=>{
      console.error(err);
    });
  }

  function showPanelsForScope(scope){
    if(scope === "general"){
      panelNeedStep.style.display = "block";
      panelResults.style.display = "none";
      stopListeners();
      return;
    }

    panelNeedStep.style.display = "none";
    panelResults.style.display = "block";

    startProgListener(scope);
    startResultsListener(scope);
  }

  // ---- Save/Clear per match
  function readCardScores(card){
    const get = (k)=>{
      const el = card.querySelector(`input[data-k="${k}"]`);
      return el ? (el.value || "").trim() : "";
    };
    return {
      s1A: get("s1A"), s1B: get("s1B"),
      s2A: get("s2A"), s2B: get("s2B"),
      s3A: get("s3A"), s3B: get("s3B"),
    };
  }

  function normalizeForStore(raw){
    // store "" as null for cleanliness
    const out = {};
    for(const k of ["s1A","s1B","s2A","s2B","s3A","s3B"]){
      const v = (raw[k] ?? "").toString().trim();
      out[k] = v === "" ? null : v;
    }
    // compute winnerSide from ints (only if enough complete sets)
    const w = calcWinnerSide(out);
    out.winnerSide = w; // "A" | "B" | null
    return out;
  }

  async function saveMatch(mid, card){
    const userEmail = auth.currentUser?.email || null;
    const raw = readCardScores(card);
    const data = normalizeForStore(raw);

    // minimal guard: if there is a tie inside a completed set, ignore (still saves)
    await setDoc(doc(resultsCol(currentScope), mid), {
      ...data,
      updatedAt: serverTimestamp(),
      updatedBy: userEmail
    }, { merge:true });
  }

  async function clearMatch(mid){
    const userEmail = auth.currentUser?.email || null;
    await setDoc(doc(resultsCol(currentScope), mid), {
      s1A:null,s1B:null,s2A:null,s2B:null,s3A:null,s3B:null,
      winnerSide: null,
      updatedAt: serverTimestamp(),
      updatedBy: userEmail
    }, { merge:true });
  }

  // live winnerSide display as you type (without saving)
  function updateWinnerPreview(card){
    const raw = readCardScores(card);
    const data = normalizeForStore(raw);
    const wEl = card.querySelector("[data-winner]");
    if(wEl) wEl.textContent = data.winnerSide || "â€”";
  }

  adminList.addEventListener("input", (e)=>{
    const card = e.target.closest(".match-card");
    if(!card) return;
    updateWinnerPreview(card);
  });

  adminList.addEventListener("click", async (e)=>{
    const btn = e.target.closest("button[data-act]");
    if(!btn) return;

    if(currentScope === "general"){ alert("Choisis une Ã©tape."); return; }
    if(!currentProg){ alert("Pas de programmation."); return; }

    const card = btn.closest(".match-card");
    const mid = card?.dataset?.mid;
    if(!mid) return;

    const act = btn.dataset.act;

    btn.disabled = true;
    try{
      if(act === "save"){
        await saveMatch(mid, card);
      }
      if(act === "clear"){
        const ok = confirm("Effacer ce rÃ©sultat ?\n\nâš ï¸ Les scores seront remis Ã  vide.");
        if(!ok) return;
        await clearMatch(mid);
      }
    }catch(err){
      console.error(err);
      alert("âŒ Erreur Firestore (droits / rules ?).");
    }finally{
      btn.disabled = false;
    }
  });

  // Logout
  document.getElementById("btnLogout").onclick = async (e)=>{
    e.preventDefault();
    await logout();
    window.location.href = "../index.html";
  };

  function showDenied(){
    accessDenied.style.display = "block";
    adminZone.style.display = "none";
    panelNeedStep.style.display = "none";
    panelResults.style.display = "none";
    stopListeners();
  }

  function showAdmin(){
    accessDenied.style.display = "none";
    adminZone.style.display = "block";

    scopeEl.value = currentScope;
    setTabs(currentScope);
    showPanelsForScope(currentScope);
    persistScope(currentScope);

    scopeEl.onchange = ()=>{
      currentScope = scopeEl.value || "general";
      setTabs(currentScope);
      showPanelsForScope(currentScope);
      persistScope(currentScope);
    };
  }

  // Guard
  const g = await requireRole(["admin"]);
  if(!g.ok){ showDenied(); }
  else { showAdmin(); }

  onAuthStateChanged(auth, async (user)=>{
    if(!user){ showDenied(); return; }
    const g2 = await requireRole(["admin"]);
    if(!g2.ok){ showDenied(); return; }
  });
</script>

</body>
</html>
