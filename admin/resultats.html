<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin ‚Äî R√©sultats</title>
  <link rel="stylesheet" href="../assets/css/main.css?v=20260222" />
</head>
<body>

<header class="topbar">
  <div class="container">
    <div class="topbar-row">
      <div class="brand-logo">
        <img src="../assets/img/logo-suzini.png" alt="Logo Suzini">
      </div>

      <h1 class="brand-title">
        üèÅ R√©sultats (admin)<br>
        <span style="opacity:.95;font-weight:800;" id="pageSub">√âtape ‚Äî</span>
      </h1>

      <div class="brand-logo">
        <img src="../assets/img/logo-challenge.png" alt="Logo Challenge">
      </div>
    </div>

    <!-- ‚úÖ Bandeau identique partout -->
    <nav class="nav">
      <a href="../index.html">Accueil public</a>
      <a href="#" id="btnLogout">D√©connexion</a>
    </nav>
  </div>
</header>

<main class="container">

  <section class="card" id="accessDenied" style="display:none;">
    <h2 style="margin:0 0 8px;">‚õî Acc√®s refus√©</h2>
    <p class="muted" style="margin:0;">Cette page est r√©serv√©e aux administrateurs.</p>
  </section>

  <!-- ‚úÖ Encart Zone (m√™me partout) -->
  <section class="card" id="adminUI" style="display:none;">
    <h2 style="margin:0 0 10px;">üéõÔ∏è Zone</h2>

    <div class="field">
      <label for="scope">Choisir</label>
      <select id="scope">
        <option value="general">G√©n√©ral</option>
        <option value="etape1">√âtape 1</option>
        <option value="etape2">√âtape 2</option>
        <option value="etape3">√âtape 3</option>
        <option value="etape4">√âtape 4</option>
        <option value="etape5">√âtape 5</option>
      </select>
    </div>

    <div class="grid" style="margin-top:10px;" id="tabs"></div>
    <p class="muted" id="hint" style="margin-top:10px;"></p>
  </section>

  <!-- =========================
       CONTENU PAGE (apr√®s Zone)
  ========================== -->

  <section class="card" id="panelNeedStep" style="display:none;">
    <h2 style="margin:0 0 8px;">‚ÑπÔ∏è Choisir une √©tape</h2>
    <p class="muted" style="margin:0;">
      S√©lectionne une <b>√âtape</b> dans ‚ÄúZone‚Äù pour g√©rer les r√©sultats.
      (Le G√©n√©ral se g√®re depuis <b>admin/index.html</b>.)
    </p>
  </section>

  <section class="card" id="panelResults" style="display:none;">
    <h2 style="margin:0 0 8px;">üèÅ R√©sultats</h2>
    <p class="muted" id="status" style="margin:0;">Chargement‚Ä¶</p>

    <hr class="sep" />

    <div class="table-wrap" style="margin-top:12px;">
      <table class="teams-table" aria-label="R√©sultats">
        <thead>
          <tr>
            <th style="width:70px;">Match</th>
            <th>Rencontre</th>

            <th style="width:200px;">Set 1<br><span class="muted">jeux (0‚Üí5)</span></th>
            <th style="width:200px;">Set 2<br><span class="muted">jeux (0‚Üí5)</span></th>
            <th style="width:220px;">Set 3<br><span class="muted">points (0‚Üí99)</span></th>

            <th style="width:130px;">Vainqueur</th>
            <th style="width:240px;">Actions</th>
          </tr>
        </thead>
        <tbody id="body"></tbody>
      </table>
    </div>

    <p class="muted" style="margin-top:10px; line-height:1.45;">
      ‚úÖ R√®gle score : <b>2 sets gagnants</b>.<br>
      ‚Ä¢ Set 1 & Set 2 : tu saisis les <b>jeux</b> (0 ‚Üí 5) pour A et B (pas d‚Äô√©galit√©).<br>
      ‚Ä¢ Si 1 set partout apr√®s 2 sets : Set 3 obligatoire en <b>points</b> (0 ‚Üí 99), pas d‚Äô√©galit√©.<br>
      ‚Ä¢ Le vainqueur est calcul√© automatiquement, mais tu peux corriger en modifiant le score puis ‚ÄúValider‚Äù.
    </p>
  </section>

</main>

<style>
  .table-wrap{ overflow:auto; border:1px solid #eee; border-radius:14px; background:#fff; }
  .teams-table{ width:100%; border-collapse:separate; border-spacing:0; min-width:1200px; }
  .teams-table thead th{
    text-align:left; font-size:13px; color:#444; background:#f7f7f7;
    border-bottom:1px solid #eee; padding:12px; position:sticky; top:0; z-index:1;
    white-space:nowrap;
  }
  .teams-table tbody td{ padding:12px; border-bottom:1px solid #f0f0f0; font-size:14px; vertical-align:top; }
  .teams-table tbody tr:last-child td{ border-bottom:none; }

  .score-row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .score-row input{
    width:64px;
    padding:10px 10px;
    border:1px solid #ddd;
    border-radius:12px;
    font-weight:900;
    text-align:center;
    background:#fff;
  }
  .score-row .lbl{ font-weight:900; }
  .pill{
    display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px;
    border:1px solid #eee; background:#fafafa; white-space:nowrap;
  }
  .pill.ok{ border-color:#cde8d1; background:#f0fbf2; font-weight:900; }
  .pill.wait{ border-color:#ffe8a8; background:#fff9df; font-weight:900; }
  .pill.err{ border-color:#f1b2b2; background:#ffecec; font-weight:900; }
  .actions{ display:flex; gap:8px; flex-wrap:wrap; }
  .btnx{
    padding:9px 12px;
    border-radius:12px;
    border:1px solid #ddd;
    background:#fff;
    cursor:pointer;
    font-weight:900;
  }
  .btnx:hover{ background:#f5f5f5; }
  .danger{ border-color:#f1b2b2; }
  .danger:hover{ background:#ffecec; }
</style>

<script type="module">
  import { auth, db } from "../assets/js/firebase.js";
  import { logout, requireRole } from "../assets/js/session.js";
  import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
  import {
    doc, getDoc, setDoc,
    collection, getDocs,
    serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  // ---- scope (URL ?scope=etape1)
  const params = new URLSearchParams(location.search);
  const scopeFromUrl = params.get("scope") || "etape1";

  // ---- dom
  const accessDenied = document.getElementById("accessDenied");
  const adminUI = document.getElementById("adminUI");

  const scopeEl = document.getElementById("scope");
  const tabsEl  = document.getElementById("tabs");
  const hintEl  = document.getElementById("hint");
  const pageSub = document.getElementById("pageSub");

  const panelNeedStep = document.getElementById("panelNeedStep");
  const panelResults  = document.getElementById("panelResults");
  const statusEl = document.getElementById("status");
  const body = document.getElementById("body");

  // ---- state
  let currentScope = scopeFromUrl;

  function stepLabel(scope){
    if(!scope || scope === "general") return "G√©n√©ral";
    const n = scope.replace("etape","");
    return `√âtape ${n}`;
  }

  function esc(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function setTabs(scope){
    tabsEl.innerHTML = "";

    if(scope === "general"){
      hintEl.textContent = "Zone G√©n√©ral : se g√®re depuis admin/index.html (infos).";
      const a = document.createElement("a");
      a.className = "btn";
      a.href = "index.html";
      a.textContent = "üì∞ Aller aux infos (G√©n√©ral)";
      tabsEl.appendChild(a);
      return;
    }

    hintEl.textContent = "Zone √âtape : programmation / √©quipes / inscriptions / tirage / r√©sultats.";

    const links = [
      ["üìÖ Programmation", "programmation.html"],
      ["üë• √âquipes", "equipes.html"],
      ["üìù Inscriptions", "inscriptions.html"],
      ["üçΩÔ∏è Repas", "repas.html"],
      ["üé≤ Tirage", "tirage.html"],
      ["üèÅ R√©sultats", "resultats.html"],
    ];

    for(const [label, url] of links){
      const a = document.createElement("a");
      a.className = "btn";
      a.href = `${url}?scope=${encodeURIComponent(scope)}`;
      a.textContent = label;

      if(url === "resultats.html"){
        a.style.fontWeight = "900";
      }
      tabsEl.appendChild(a);
    }
  }

  function showPanelsForScope(scope){
    pageSub.textContent = scope === "general" ? "G√©n√©ral" : `${stepLabel(scope)} ‚Äî BT250`;

    if(scope === "general"){
      panelNeedStep.style.display = "block";
      panelResults.style.display = "none";
      return;
    }

    panelNeedStep.style.display = "none";
    panelResults.style.display = "block";
  }

  function showDenied(){
    accessDenied.style.display = "block";
    adminUI.style.display = "none";
    panelNeedStep.style.display = "none";
    panelResults.style.display = "none";
  }

  function showAdmin(){
    accessDenied.style.display = "none";
    adminUI.style.display = "block";

    scopeEl.value = currentScope;
    setTabs(currentScope);
    showPanelsForScope(currentScope);

    scopeEl.onchange = async ()=>{
      currentScope = scopeEl.value || "general";
      setTabs(currentScope);
      showPanelsForScope(currentScope);
      await refresh();
    };
  }

  // ============================================================
  // LOGIQUE RESULTATS
  // - tirages/{scope} => TS1/TS2 + 6 tir√©es
  // - resultats_{scope}/{M1..M12} => propagation V/P
  // - stockage conforme rules : matchId, winnerSide, score, updatedAt, validatedBy
  //   + META JSON encod√© dans score pour stats (classement futur)
  // ============================================================
  const MATCH_IDS = Array.from({length:12}, (_,i)=> `M${i+1}`);

  function parseMetaFromScore(scoreStr){
    if(!scoreStr) return null;
    const idx = scoreStr.indexOf("META:");
    if(idx < 0) return null;
    const raw = scoreStr.slice(idx + 5).trim();
    try { return JSON.parse(raw); } catch { return null; }
  }

  function buildScoreString(human, metaObj){
    const meta = JSON.stringify(metaObj || {});
    return `${human}\nMETA:${meta}`;
  }

  function clampInt(v, min, max){
    if(v === "" || v === null || v === undefined) return null;
    const n = Number(String(v).trim());
    if(!Number.isFinite(n)) return null;
    const i = Math.trunc(n);
    if(i < min || i > max) return null;
    return i;
  }

  // set1/2 : jeux 0..5, set3 : points 0..99
  function computeWinnerAndStats(s1a, s1b, s2a, s2b, s3a, s3b){
    const err = (msg)=> ({ ok:false, msg });

    // set1 & set2 obligatoires
    if(s1a === null || s1b === null) return err("Set 1 incomplet.");
    if(s2a === null || s2b === null) return err("Set 2 incomplet.");
    if(s1a === s1b) return err("Set 1 : √©galit√© interdite.");
    if(s2a === s2b) return err("Set 2 : √©galit√© interdite.");

    const w1 = (s1a > s1b) ? "A" : "B";
    const w2 = (s2a > s2b) ? "A" : "B";

    let setsA = 0, setsB = 0;
    if(w1 === "A") setsA++; else setsB++;
    if(w2 === "A") setsA++; else setsB++;

    // si 2-0 => set3 doit √™tre vide
    if(setsA === 2 || setsB === 2){
      if((s3a !== null) || (s3b !== null)){
        return err("Set 3 interdit si victoire en 2 sets. Vide les points du Set 3.");
      }
      const winnerSide = (setsA === 2) ? "A" : "B";
      return {
        ok:true,
        winnerSide,
        stats:{
          s1a,s1b,s2a,s2b,s3a:null,s3b:null,
          setsA, setsB,
          gamesA: s1a + s2a,
          gamesB: s1b + s2b,
          pointsA: 0,
          pointsB: 0
        }
      };
    }

    // sinon 1-1 => set3 obligatoire
    if(s3a === null || s3b === null) return err("Set 3 obligatoire (1 set partout).");
    if(s3a === s3b) return err("Set 3 : √©galit√© interdite.");

    const w3 = (s3a > s3b) ? "A" : "B";
    if(w3 === "A") setsA++; else setsB++;

    const winnerSide = (setsA > setsB) ? "A" : "B";
    return {
      ok:true,
      winnerSide,
      stats:{
        s1a,s1b,s2a,s2b,s3a,s3b,
        setsA, setsB,
        gamesA: s1a + s2a,
        gamesB: s1b + s2b,
        pointsA: s3a,
        pointsB: s3b
      }
    };
  }

  async function readDraw(scope){
    const ref = doc(db, "tirages", scope);
    const snap = await getDoc(ref);
    return snap.exists() ? (snap.data() || null) : null;
  }

  async function readResults(scope){
    const colName = `resultats_${scope}`;
    const snap = await getDocs(collection(db, colName));
    const byId = new Map();
    snap.forEach(d=>{
      byId.set(d.id, d.data() || {});
    });
    return byId;
  }

  function tLabel(t){
    if(!t) return "‚Äî";
    return `${t.teamName || "√âquipe"} (${t.p1FirstName || "?"} / ${t.p2FirstName || "?"})`;
  }

  function resolveTeamByCode(ctx, code){
    // code patterns:
    // TS1, TS2, E3..E8, V1..V8, P1..P8
    if(!code) return null;

    if(code === "TS1") return ctx.TS1 || null;
    if(code === "TS2") return ctx.TS2 || null;

    const e = code.match(/^E([3-8])$/);
    if(e){
      const idx = Number(e[1]) - 3; // E3->0 ... E8->5
      return (ctx.E && ctx.E[idx]) ? ctx.E[idx] : null;
    }

    const v = code.match(/^V([1-8])$/);
    if(v){
      const m = Number(v[1]); // winner of M#
      return ctx.V.get(`M${m}`) || null;
    }

    const p = code.match(/^P([1-8])$/);
    if(p){
      const m = Number(p[1]); // loser of M#
      return ctx.P.get(`M${m}`) || null;
    }

    return null;
  }

  function computeBracket(draw, resultsById){
    // Build context:
    // TS1/TS2 from draw
    // E3..E8 from draw order (revealed order)
    // then derive winners/losers from existing results
    const ctx = {
      TS1: draw?.seed1 || null,
      TS2: draw?.seed2 || null,
      E: [],
      V: new Map(),
      P: new Map()
    };

    // Need 6 teams drawn (pool + order)
    const pool = draw?.pool || [];
    const order = draw?.order || [];
    const poolById = new Map(pool.map(x => [x.id, x]));
    const revealed = Math.min(6, Number(draw?.revealed || 0));
    const revealedIds = order.slice(0, revealed);
    const revealedTeams = revealedIds.map(id => poolById.get(id)).filter(Boolean);

    // E3..E8 mapping
    // E3=pick1, E4=pick2, ..., E8=pick6
    ctx.E = revealedTeams.slice(0,6);

    // helper to compute winner/loser from stored doc
    const getWinLose = (matchId)=>{
      const d = resultsById.get(matchId);
      if(!d) return { winner:null, loser:null };
      const meta = parseMetaFromScore(d.score || "");
      // fallback: use winnerSide only
      const winnerSide = d.winnerSide || null;

      return { winnerSide, meta };
    };

    // Define match participants by codes (according to your programming type)
    const matchDefs = [
      // M1..M4
      { id:"M1", A:"E4", B:"E5" },        // pick2 vs pick3
      { id:"M2", A:"E6", B:"E7" },        // pick4 vs pick5
      { id:"M3", A:"TS1", B:"E3" },       // TS1 vs pick1
      { id:"M4", A:"E8", B:"TS2" },       // pick6 vs TS2  (comme ton tableau public)
      // losers bracket
      { id:"M5", A:"P1", B:"P2" },
      { id:"M6", A:"P3", B:"P4" },
      // winners bracket
      { id:"M7", A:"V1", B:"V2" },
      { id:"M8", A:"V3", B:"V4" },
      // placement
      { id:"M9",  A:"P5", B:"P6" },       // 7/8
      { id:"M10", A:"V5", B:"V6" },       // 5/6
      { id:"M11", A:"P7", B:"P8" },       // 3/4
      { id:"M12", A:"V7", B:"V8" }        // finale
    ];

    // compute winners/losers progressively using stored results
    for(const md of matchDefs){
      const aTeam = resolveTeamByCode(ctx, md.A);
      const bTeam = resolveTeamByCode(ctx, md.B);

      // determine winner/loser if result exists
      const r = resultsById.get(md.id);
      if(!r) continue;

      const winnerSide = r.winnerSide || null;
      if(!winnerSide) continue;

      const winner = (winnerSide === "A") ? aTeam : bTeam;
      const loser  = (winnerSide === "A") ? bTeam : aTeam;

      ctx.V.set(md.id, winner || null);
      ctx.P.set(md.id, loser  || null);
    }

    return { ctx, matchDefs };
  }

  function renderTable({ draw, resultsById }){
    body.innerHTML = "";

    // draw might be null / not ready
    const { ctx, matchDefs } = computeBracket(draw, resultsById);

    const drawReady = !!(draw && draw.seed1 && draw.seed2 && (draw.revealed || 0) >= 6);
    const drawStatus = draw?.status || "idle";

    // status
    if(!draw){
      statusEl.textContent = "‚è≥ Aucun tirage trouv√© pour cette √©tape. Va sur Admin ‚Üí Tirage.";
    } else if(!drawReady){
      statusEl.textContent = `‚ö†Ô∏è Tirage pas pr√™t : il faut 6 √©quipes tir√©es (actuel: ${draw.revealed || 0}/6). Statut: ${drawStatus}.`;
    } else {
      statusEl.textContent = `‚úÖ Tirage pr√™t (6/6). Statut tirage: ${drawStatus}. Tu peux saisir/valider les scores.`;
    }

    for(const md of matchDefs){
      const aTeam = resolveTeamByCode(ctx, md.A);
      const bTeam = resolveTeamByCode(ctx, md.B);

      // Match jouable si A & B connus
      const playable = !!(aTeam && bTeam);

      const existing = resultsById.get(md.id) || null;
      const meta = existing ? parseMetaFromScore(existing.score || "") : null;

      const pre = meta || {};
      const s1a = (pre.s1a ?? "");
      const s1b = (pre.s1b ?? "");
      const s2a = (pre.s2a ?? "");
      const s2b = (pre.s2b ?? "");
      const s3a = (pre.s3a ?? "");
      const s3b = (pre.s3b ?? "");

      let winnerPill = `<span class="pill wait">‚Äî</span>`;
      if(existing?.winnerSide === "A") winnerPill = `<span class="pill ok">A</span>`;
      if(existing?.winnerSide === "B") winnerPill = `<span class="pill ok">B</span>`;

      const row = document.createElement("tr");
      row.innerHTML = `
        <td><b>${esc(md.id)}</b></td>
        <td>
          <div style="font-weight:900;">${esc(tLabel(aTeam))} <span class="muted">vs</span> ${esc(tLabel(bTeam))}</div>
          <div class="muted" style="margin-top:6px;">
            <span class="pill">${esc(md.A)}</span>
            <span class="pill">${esc(md.B)}</span>
            ${playable ? "" : `<span class="pill err">‚ö†Ô∏è En attente √©quipes</span>`}
            ${existing ? `<span class="pill ok">‚úÖ Enregistr√©</span>` : `<span class="pill wait">‚è≥ Non saisi</span>`}
          </div>
        </td>

        <td>
          <div class="score-row">
            <span class="lbl">A</span><input inputmode="numeric" data-k="s1a" value="${esc(String(s1a))}" ${!playable ? "disabled" : ""} />
            <span class="muted">-</span>
            <span class="lbl">B</span><input inputmode="numeric" data-k="s1b" value="${esc(String(s1b))}" ${!playable ? "disabled" : ""} />
          </div>
        </td>

        <td>
          <div class="score-row">
            <span class="lbl">A</span><input inputmode="numeric" data-k="s2a" value="${esc(String(s2a))}" ${!playable ? "disabled" : ""} />
            <span class="muted">-</span>
            <span class="lbl">B</span><input inputmode="numeric" data-k="s2b" value="${esc(String(s2b))}" ${!playable ? "disabled" : ""} />
          </div>
        </td>

        <td>
          <div class="score-row">
            <span class="lbl">A</span><input inputmode="numeric" data-k="s3a" placeholder="(si 1-1)" value="${esc(String(s3a))}" ${!playable ? "disabled" : ""} />
            <span class="muted">-</span>
            <span class="lbl">B</span><input inputmode="numeric" data-k="s3b" placeholder="(si 1-1)" value="${esc(String(s3b))}" ${!playable ? "disabled" : ""} />
          </div>
        </td>

        <td>${winnerPill}</td>

        <td>
          <div class="actions">
            <button class="btnx" data-act="save" ${!playable ? "disabled" : ""}>‚úÖ Valider</button>
            <button class="btnx" data-act="clear" ${!playable ? "disabled" : ""}>üßΩ Effacer</button>
          </div>
          <div class="muted" data-msg style="margin-top:8px;"></div>
        </td>
      `;

      // attach behavior
      const getInputs = ()=> {
        const map = {};
        row.querySelectorAll("input[data-k]").forEach(inp=>{
          map[inp.dataset.k] = inp;
        });
        return map;
      };

      row.querySelector('[data-act="save"]').onclick = async ()=>{
        const msgEl = row.querySelector('[data-msg]');
        msgEl.textContent = "Validation‚Ä¶";

        try{
          const inputs = getInputs();
          // parse values
          const v1a = clampInt(inputs.s1a.value, 0, 5);
          const v1b = clampInt(inputs.s1b.value, 0, 5);
          const v2a = clampInt(inputs.s2a.value, 0, 5);
          const v2b = clampInt(inputs.s2b.value, 0, 5);

          // set3 points allow empty (null)
          const raw3a = inputs.s3a.value.trim();
          const raw3b = inputs.s3b.value.trim();
          const v3a = raw3a === "" ? null : clampInt(raw3a, 0, 99);
          const v3b = raw3b === "" ? null : clampInt(raw3b, 0, 99);

          if(raw3a !== "" && v3a === null) throw new Error("Set 3 A invalide (0‚Üí99).");
          if(raw3b !== "" && v3b === null) throw new Error("Set 3 B invalide (0‚Üí99).");

          const res = computeWinnerAndStats(v1a, v1b, v2a, v2b, v3a, v3b);
          if(!res.ok) throw new Error(res.msg);

          const human = (()=>{
            // human readable
            const s1 = `${v1a}-${v1b}`;
            const s2 = `${v2a}-${v2b}`;
            if(res.stats.s3a === null) return `${s1} ${s2}`;
            return `${s1} ${s2} TB ${res.stats.s3a}-${res.stats.s3b}`;
          })();

          // meta enrichi (utile futur classement)
          const metaOut = {
            ...res.stats,
            // qui joue (labels) : pratique pour debug/trace
            A: { code: md.A, label: tLabel(aTeam) },
            B: { code: md.B, label: tLabel(bTeam) }
          };

          // conforme √† TES RULES actuelles:
          // { matchId, winnerSide, score, updatedAt, validatedBy }
          const payload = {
            matchId: md.id,
            winnerSide: res.winnerSide,
            score: buildScoreString(human, metaOut),
            updatedAt: serverTimestamp(),
            validatedBy: (auth.currentUser?.email || null)
          };

          const colName = `resultats_${currentScope}`;
          await setDoc(doc(db, colName, md.id), payload, { merge:true });

          msgEl.textContent = `‚úÖ Enregistr√© (vainqueur ${res.winnerSide})`;
          await refresh(); // re-render + propagation V/P
        }catch(err){
          console.error(err);
          const msg = err?.message || "Erreur";
          row.querySelector('[data-msg]').textContent = "‚ùå " + msg;
        }
      };

      row.querySelector('[data-act="clear"]').onclick = async ()=>{
        const msgEl = row.querySelector('[data-msg]');
        const ok = confirm(`Effacer les champs du match ${md.id} (local) ?\n\n‚ö†Ô∏è √áa ne supprime pas Firestore, √ßa remet juste les inputs √† vide.\n(Utilise ensuite Valider si tu veux √©craser.)`);
        if(!ok) return;
        const inputs = getInputs();
        ["s1a","s1b","s2a","s2b","s3a","s3b"].forEach(k => inputs[k].value = "");
        msgEl.textContent = "üßΩ Champs effac√©s.";
      };

      body.appendChild(row);
    }
  }

  async function refresh(){
    if(currentScope === "general"){
      statusEl.textContent = "‚Äî";
      body.innerHTML = "";
      return;
    }

    statusEl.textContent = "Chargement‚Ä¶";

    const [draw, resultsById] = await Promise.all([
      readDraw(currentScope),
      readResults(currentScope)
    ]);

    renderTable({ draw, resultsById });
  }

  // Guard (persistance via session.js)
  const g = await requireRole(["admin"]);
  if(!g.ok){
    showDenied();
  }else{
    showAdmin();
    await refresh();
  }

  // robuste si session change
  onAuthStateChanged(auth, async (user)=>{
    if(!user){ showDenied(); return; }
    const g2 = await requireRole(["admin"]);
    if(!g2.ok){ showDenied(); return; }
  });

  // Logout
  document.getElementById("btnLogout").onclick = async (e)=>{
    e.preventDefault();
    await logout();
    window.location.href = "../index.html";
  };
</script>

</body>
</html>
