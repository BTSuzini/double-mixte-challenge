<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Admin ‚Äî R√©sultats</title>
  <link rel="stylesheet" href="../assets/css/main.css?v=20260222" />
</head>
<body>

<header class="topbar">
  <div class="container">
    <div class="topbar-row">
      <div class="brand-logo">
        <img src="../assets/img/logo-suzini.png" alt="Logo Suzini">
      </div>

      <h1 class="brand-title">
        üèÅ R√©sultats (admin)<br>
        <span style="opacity:.95;font-weight:800;" id="pageSub">√âtape ‚Äî</span>
      </h1>

      <div class="brand-logo">
        <img src="../assets/img/logo-challenge.png" alt="Logo Challenge">
      </div>
    </div>

    <nav class="nav">
      <a href="../index.html">Accueil public</a>
      <a href="#" id="btnLogout">D√©connexion</a>
    </nav>
  </div>
</header>

<main class="container">

  <section class="card" id="accessDenied" style="display:none;">
    <h2 style="margin:0 0 8px;">‚õî Acc√®s refus√©</h2>
    <p class="muted" style="margin:0;">Cette page est r√©serv√©e aux administrateurs.</p>
  </section>

  <!-- ‚úÖ Encart Zone (m√™me partout) -->
  <section class="card" id="adminUI" style="display:none;">
    <h2 style="margin:0 0 10px;">üéõÔ∏è Zone</h2>

    <div class="field">
      <label for="scope">Choisir</label>
      <select id="scope">
        <option value="general">G√©n√©ral</option>
        <option value="etape1">√âtape 1</option>
        <option value="etape2">√âtape 2</option>
        <option value="etape3">√âtape 3</option>
        <option value="etape4">√âtape 4</option>
        <option value="etape5">√âtape 5</option>
      </select>
    </div>

    <div class="grid" style="margin-top:10px;" id="tabs"></div>
    <p class="muted" id="hint" style="margin-top:10px;"></p>
  </section>

  <section class="card" id="panelNeedStep" style="display:none;">
    <h2 style="margin:0 0 8px;">‚ÑπÔ∏è Choisir une √©tape</h2>
    <p class="muted" style="margin:0;">
      S√©lectionne une <b>√âtape</b> dans ‚ÄúZone‚Äù pour g√©rer les r√©sultats.
    </p>
  </section>

  <section class="card" id="panelResults" style="display:none;">
    <h2 style="margin:0 0 10px;">üèÅ R√©sultats</h2>
    <p class="muted" id="statusText" style="margin:0;">Chargement‚Ä¶</p>

    <div class="grid" style="margin-top:12px;">
      <button class="btn" id="btnOpenPublic" style="font-weight:900; color:#111;">
        üëÄ Ouvrir la programmation (public)
      </button>
    </div>

    <p class="muted" style="margin-top:12px;">
      ‚úÖ Format score :
      <br>‚Ä¢ Sets 1 & 2 : <b>jeux</b> (0‚Äì5), l‚Äô√©quipe qui a le plus de jeux gagne le set
      <br>‚Ä¢ Set 3 (si 1‚Äì1) : <b>tie-break</b> en points (0‚Äì99)
      <br>Les <b>manches/jeux/points</b> sont calcul√©s et stock√©s pour le futur onglet classement.
    </p>

    <div id="matchCards" style="display:grid; gap:12px; margin-top:14px;"></div>
  </section>

</main>

<style>
  .pill{
    display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px;
    border:1px solid #eee; background:#fafafa; white-space:nowrap;
  }

  /* --- Match cards (responsive) --- */
  .match-card{
    border-radius:16px;
    border:1px solid rgba(0,0,0,.06);
    overflow:hidden;
    background:#fff;
  }
  .match-card.yellow{ background:rgba(255, 221, 87, .22); border-color:rgba(255, 221, 87, .55); }
  .match-card.red{ background:rgba(255, 77, 77, .12); border-color:rgba(255, 77, 77, .28); }

  .match-inner{
    padding:12px;
    display:flex;
    gap:12px;
    align-items:stretch;
  }

  .match-left{ flex:1 1 auto; min-width:0; }

  .match-topline{
    display:flex;
    justify-content:space-between;
    align-items:baseline;
    gap:10px;
  }

  .when-line{
    display:flex;
    align-items:baseline;
    gap:10px;
    min-width:0;
  }

  .when-time{
    font-weight:1000;
    font-size:20px;
    letter-spacing:.2px;
    white-space:nowrap;
  }

  /* court small, non-bold, single line */
  .when-court{
    font-size:13px;
    font-weight:600;
    opacity:.92;
    font-style:italic;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  .status-emoji{
    font-size:18px;
    line-height:1;
    white-space:nowrap;
  }

  .teams{
    margin-top:10px;
    display:grid;
    gap:8px;
  }
  .team-name{
    font-weight:950;
    font-size:18px;
    line-height:1.15;
    word-break:break-word;
  }
  .vsline{
    text-align:center;
    font-weight:900;
    opacity:.55;
    letter-spacing:.25em;
  }

  .match-right{
    width:170px;
    flex:0 0 auto;
    display:flex;
    flex-direction:column;
    gap:10px;
    align-items:stretch;
    justify-content:space-between;
  }

  .scorebox{
    border:1px solid rgba(0,0,0,.08);
    background:rgba(255,255,255,.70);
    border-radius:16px;
    padding:10px 10px;
    display:flex;
    flex-direction:column;
    gap:10px;
    justify-content:center;
  }

  .muted-mini{
    font-size:12px;
    opacity:.7;
  }

  .score-grid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:8px;
  }

  .score-row{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
  }

  .ibox{
    width:54px;
    height:40px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.12);
    background:#fff;
    font-weight:900;
    font-size:16px;
    text-align:center;
    outline:none;
  }
  .ibox:focus{ box-shadow: 0 0 0 3px rgba(0,0,0,.06); }

  .btnsave{
    width:100%;
    padding:11px 12px;
    border-radius:14px;
    border:1px solid rgba(0,0,0,.12);
    background:#fff;
    cursor:pointer;
    font-weight:1000;
  }
  .btnsave:hover{ background:rgba(255,255,255,.8); }
  .btnsave:disabled{ opacity:.6; cursor:not-allowed; }

  .errline{
    margin-top:8px;
    font-size:12px;
    font-weight:900;
    color:#b00020;
    display:none;
  }

  @media (max-width: 420px){
    .match-inner{ padding:10px; gap:10px; }
    .when-time{ font-size:18px; }
    .team-name{ font-size:16px; }
    .match-right{ width:160px; }
    .ibox{ width:50px; height:40px; }
  }
</style>

<script type="module">
  import { auth, db } from "../assets/js/firebase.js";
  import { logout, requireRole } from "../assets/js/session.js";

  import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
  import {
    doc, getDoc, onSnapshot, collection, setDoc,
    serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  // ---- scope (URL ?scope=etape1)
  const params = new URLSearchParams(location.search);
  const scopeFromUrl = params.get("scope") || "etape1";

  // ---- DOM
  const accessDenied = document.getElementById("accessDenied");
  const adminUI = document.getElementById("adminUI");

  const scopeEl = document.getElementById("scope");
  const tabsEl  = document.getElementById("tabs");
  const hintEl  = document.getElementById("hint");
  const pageSub = document.getElementById("pageSub");

  const panelNeedStep = document.getElementById("panelNeedStep");
  const panelResults  = document.getElementById("panelResults");
  const statusText    = document.getElementById("statusText");
  const matchCards    = document.getElementById("matchCards");
  const btnOpenPublic = document.getElementById("btnOpenPublic");

  // ---- state
  let currentScope = scopeFromUrl;
  let currentProg = null;
  let resultsByMatch = new Map(); // matchId -> stored result doc
  let unsubProg = null;
  let unsubRes = null;

  function stepLabel(scope){
    if(!scope || scope === "general") return "G√©n√©ral";
    const n = scope.replace("etape","");
    return `√âtape ${n}`;
  }

  function esc(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  }

  function setTabs(scope){
    tabsEl.innerHTML = "";

    if(scope === "general"){
      hintEl.textContent = "Zone G√©n√©ral : se g√®re depuis admin/index.html (infos).";
      const a = document.createElement("a");
      a.className = "btn";
      a.href = "index.html";
      a.textContent = "üì∞ Aller aux infos (G√©n√©ral)";
      tabsEl.appendChild(a);
      return;
    }

    hintEl.textContent = "Zone √âtape : √©quipes / inscriptions / tirage / programmation / r√©sultats.";

    const links = [
      ["üë• √âquipes", "equipes.html"],
      ["üìù Inscriptions", "inscriptions.html"],
      ["üé≤ Tirage", "tirage.html"],
      ["üìÖ Programmation", "programmation.html"],
      ["üèÅ R√©sultats", "resultats.html"],
    ];

    for(const [label, url] of links){
      const a = document.createElement("a");
      a.className = "btn";
      a.href = `${url}?scope=${encodeURIComponent(scope)}`;
      a.textContent = label;
      if(url === "resultats.html") a.style.fontWeight = "900";
      tabsEl.appendChild(a);
    }
  }

  function stopListeners(){
    if(unsubProg){ unsubProg(); unsubProg = null; }
    if(unsubRes){ unsubRes(); unsubRes = null; }
  }

  function showPanelsForScope(scope){
    pageSub.textContent = scope === "general" ? "G√©n√©ral" : `${stepLabel(scope)} ‚Äî BT250`;

    if(scope === "general"){
      panelNeedStep.style.display = "block";
      panelResults.style.display = "none";
      stopListeners();
      return;
    }

    panelNeedStep.style.display = "none";
    panelResults.style.display = "block";

    startProgListener(scope);
    startResultsListener(scope);
  }

  // ---- Firestore refs
  function progRef(scope){ return doc(db, "programmations", scope); }
  function resultsCol(scope){ return collection(db, `resultats_${scope}`); }

  function courtName(courtKey){
    const c = currentProg?.courts || {};
    return c[courtKey] || (courtKey || "‚Äî");
  }

  function courtDecor(courtKey){
    if(courtKey === "A") return { cls:"yellow", emo:"üêù" };
    if(courtKey === "B") return { cls:"red", emo:"üå∂Ô∏è" };
    return { cls:"", emo:"üéæ" };
  }

  function teamLabel(t){
    if(!t) return "‚Äî";
    return `${t.teamName || "√âquipe"} (${t.p1FirstName || "?"} / ${t.p2FirstName || "?"})`;
  }

  // R√©solution des √©quipes (direct / winner / loser)
  function resolveTeamRef(ref){
    if(!currentProg) return null;

    const teams = currentProg.teams || {};
    const matches = currentProg.matches || {};

    if(!ref) return null;

    if(ref.type === "team"){
      return teams[ref.key] || null;
    }

    if(ref.type === "winner" || ref.type === "loser"){
      const mid = ref.matchId;
      const m = matches[mid];
      if(!m) return null;

      const res = resultsByMatch.get(mid);
      if(!res || (res.winnerSide !== "A" && res.winnerSide !== "B")) return null;

      const teamA = resolveTeamRef(m.A);
      const teamB = resolveTeamRef(m.B);

      const winner = (res.winnerSide === "A") ? teamA : teamB;
      const loser  = (res.winnerSide === "A") ? teamB : teamA;

      return ref.type === "winner" ? winner : loser;
    }

    return null;
  }

  function parseHHMM(hhmm){
    const m = String(hhmm || "").match(/^(\d{1,2}):(\d{2})$/);
    if(!m) return null;
    const H = Number(m[1]), M = Number(m[2]);
    if(!Number.isFinite(H) || !Number.isFinite(M)) return null;
    return { H, M };
  }

  function statusEmoji(slotTime, done){
    if(done) return "‚úÖ";
    const p = parseHHMM(slotTime);
    if(!p) return "‚è≥";
    const now = new Date();
    const start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), p.H, p.M, 0, 0);
    return now >= start ? "üü¢" : "‚è≥";
  }

  function toIntOrNull(v){
    if(v === "" || v === null || typeof v === "undefined") return null;
    const n = Number(v);
    if(!Number.isFinite(n)) return null;
    if(!Number.isInteger(n)) return null;
    return n;
  }

  function clampRange(n, min, max){
    if(n === null) return null;
    if(n < min || n > max) return null;
    return n;
  }

  function setWinnerFromSetGames(a, b){
    if(a === null || b === null) return null;
    if(a === b) return null;
    return (a > b) ? "A" : "B";
  }

  function computeOutcome(inputs){
    // inputs:
    // s1A,s1B,s2A,s2B in 0..5 (or null)
    // s3A,s3B in 0..99 (or null)
    const s1A = clampRange(inputs.s1A, 0, 5);
    const s1B = clampRange(inputs.s1B, 0, 5);
    const s2A = clampRange(inputs.s2A, 0, 5);
    const s2B = clampRange(inputs.s2B, 0, 5);
    const s3A = clampRange(inputs.s3A, 0, 99);
    const s3B = clampRange(inputs.s3B, 0, 99);

    const errs = [];

    // if one side filled, other must be filled
    function paired(a,b,label){
      const filledA = (a !== null);
      const filledB = (b !== null);
      if(filledA !== filledB){
        errs.push(`${label} : renseigner les 2 scores.`);
      }
    }
    paired(s1A,s1B,"Set 1");
    paired(s2A,s2B,"Set 2");
    paired(s3A,s3B,"Set 3 (TB)");

    // Validate set 1 & 2 if filled: must not be equal
    const w1 = setWinnerFromSetGames(s1A,s1B);
    if(s1A !== null && s1B !== null && !w1) errs.push("Set 1 : √©galit√© impossible.");
    const w2 = setWinnerFromSetGames(s2A,s2B);
    if(s2A !== null && s2B !== null && !w2) errs.push("Set 2 : √©galit√© impossible.");

    // Determine if match is complete
    let setsA = 0, setsB = 0;
    if(w1 === "A") setsA++; else if(w1 === "B") setsB++;
    if(w2 === "A") setsA++; else if(w2 === "B") setsB++;

    const needTB = (w1 && w2 && setsA === 1 && setsB === 1);

    // If match decided in 2 sets (2-0), TB must be empty
    if(w1 && w2 && (setsA === 2 || setsB === 2)){
      if(s3A !== null || s3B !== null) errs.push("Set 3 : √† laisser vide (match gagn√© en 2 sets).");
    }

    let w3 = null;
    if(needTB){
      if(s3A === null || s3B === null){
        // allow not complete yet (in progress), but no error
      } else {
        if(s3A === s3B) errs.push("Set 3 : √©galit√© impossible.");
        w3 = (s3A > s3B) ? "A" : "B";
        if(w3 === "A") setsA++; else setsB++;
      }
    }

    // if TB entered but sets not 1-1 => error already above; still compute safety

    const complete = (setsA === 2 || setsB === 2);

    // Aggregate stats for later classement
    const gamesA = (s1A ?? 0) + (s2A ?? 0);
    const gamesB = (s1B ?? 0) + (s2B ?? 0);

    const tbA = (needTB && s3A !== null) ? s3A : 0;
    const tbB = (needTB && s3B !== null) ? s3B : 0;

    // score lines (top A / bottom B)
    function fmtPart(x){ return (x === null) ? "‚Äî" : String(x); }
    const scoreA = `${fmtPart(s1A)} / ${fmtPart(s2A)}${needTB ? " / " + fmtPart(s3A) : ""}`;
    const scoreB = `${fmtPart(s1B)} / ${fmtPart(s2B)}${needTB ? " / " + fmtPart(s3B) : ""}`;

    // compact score string
    let score = "";
    if(s1A !== null && s1B !== null) score += `${s1A}-${s1B}`;
    if(s2A !== null && s2B !== null) score += (score ? " " : "") + `${s2A}-${s2B}`;
    if(needTB && s3A !== null && s3B !== null) score += (score ? " " : "") + `${s3A}-${s3B}`;

    // winnerSide only if complete
    const winnerSide = complete ? (setsA > setsB ? "A" : "B") : null;

    // Additional validation: if set1+set2 not both filled, match can't be complete
    if(complete && !(w1 && w2)) errs.push("Impossible de valider : renseigner Set 1 et Set 2.");

    // TB allowed only when needTB (already handled)
    // ranges already handled by clampRange; if user typed out of range -> becomes null, then paired() will flag mismatch
    if(inputs.s1A !== null && s1A === null) errs.push("Set 1A : valeur invalide (0‚Äì5).");
    if(inputs.s1B !== null && s1B === null) errs.push("Set 1B : valeur invalide (0‚Äì5).");
    if(inputs.s2A !== null && s2A === null) errs.push("Set 2A : valeur invalide (0‚Äì5).");
    if(inputs.s2B !== null && s2B === null) errs.push("Set 2B : valeur invalide (0‚Äì5).");
    if(inputs.s3A !== null && s3A === null) errs.push("Set 3A : valeur invalide (0‚Äì99).");
    if(inputs.s3B !== null && s3B === null) errs.push("Set 3B : valeur invalide (0‚Äì99).");

    return {
      ok: errs.length === 0,
      errs,
      needTB,
      complete,
      winnerSide,
      setsA, setsB,
      gamesA, gamesB,
      tbA, tbB,
      s1A, s1B, s2A, s2B, s3A, s3B,
      scoreA, scoreB,
      score
    };
  }

  function renderAll(){
    if(!currentProg){
      matchCards.innerHTML = "";
      statusText.textContent = "‚è≥ Programmation non disponible (g√©n√®re-la d‚Äôabord).";
      return;
    }

    const matches = currentProg.matches || {};
    const slots = Array.isArray(currentProg.slots) ? currentProg.slots : [];
    const schedule = currentProg.schedule || {};

    // slot -> matchId
    const slotToMatch = new Map();
    Object.entries(schedule).forEach(([mid, slotNum])=>{
      slotToMatch.set(Number(slotNum), mid);
    });

    const cards = [];
    for(const s of slots){
      const mid = slotToMatch.get(Number(s.slot));
      const m = mid ? matches[mid] : null;
      if(!m) continue;

      const teamA = resolveTeamRef(m.A);
      const teamB = resolveTeamRef(m.B);

      const aTxt = teamA ? teamLabel(teamA) : (m.A.type === "team" ? m.A.key : (m.A.type === "winner" ? `V${m.A.matchId.slice(1)}` : `P${m.A.matchId.slice(1)}`));
      const bTxt = teamB ? teamLabel(teamB) : (m.B.type === "team" ? m.B.key : (m.B.type === "winner" ? `V${m.B.matchId.slice(1)}` : `P${m.B.matchId.slice(1)}`));

      const deco = courtDecor(s.court);
      const courtTxt = courtName(s.court);

      const stored = resultsByMatch.get(mid) || {};
      const done = (stored.winnerSide === "A" || stored.winnerSide === "B");
      const st = statusEmoji(s.time, done);

      // Pre-fill inputs
      const v = {
        s1A: stored.s1A ?? null,
        s1B: stored.s1B ?? null,
        s2A: stored.s2A ?? null,
        s2B: stored.s2B ?? null,
        s3A: stored.s3A ?? null,
        s3B: stored.s3B ?? null
      };

      cards.push(`
        <div class="match-card ${esc(deco.cls)}" data-mid="${esc(mid)}">
          <div class="match-inner">
            <div class="match-left">
              <div class="match-topline">
                <div class="when-line">
                  <div class="when-time">${esc(s.time)}</div>
                  <div class="when-court">${esc(deco.emo)} ${esc(courtTxt)} ${esc(deco.emo)}</div>
                </div>
                <div class="status-emoji" title="Statut">${esc(st)}</div>
              </div>

              ${s.note ? `<div class="muted-mini" style="margin-top:6px;">‚ö†Ô∏è ${esc(s.note)}</div>` : ""}

              <div class="teams">
                <div class="team-name">${esc(aTxt)}</div>
                <div class="vsline">VS</div>
                <div class="team-name">${esc(bTxt)}</div>
              </div>

              <div class="errline" id="err-${esc(mid)}"></div>
            </div>

            <div class="match-right">
              <div class="scorebox">
                <div class="muted-mini" style="font-weight:900;">S1 / S2 / TB</div>

                <div class="score-grid">
                  <div>
                    <div class="muted-mini" style="font-weight:900; margin-bottom:6px;">A</div>
                    <div class="score-row">
                      <input class="ibox" inputmode="numeric" pattern="[0-9]*" maxlength="2" data-mid="${esc(mid)}" data-k="s1A" value="${v.s1A ?? ""}">
                      <input class="ibox" inputmode="numeric" pattern="[0-9]*" maxlength="2" data-mid="${esc(mid)}" data-k="s2A" value="${v.s2A ?? ""}">
                      <input class="ibox" inputmode="numeric" pattern="[0-9]*" maxlength="2" data-mid="${esc(mid)}" data-k="s3A" value="${v.s3A ?? ""}">
                    </div>
                  </div>

                  <div>
                    <div class="muted-mini" style="font-weight:900; margin-bottom:6px;">B</div>
                    <div class="score-row">
                      <input class="ibox" inputmode="numeric" pattern="[0-9]*" maxlength="2" data-mid="${esc(mid)}" data-k="s1B" value="${v.s1B ?? ""}">
                      <input class="ibox" inputmode="numeric" pattern="[0-9]*" maxlength="2" data-mid="${esc(mid)}" data-k="s2B" value="${v.s2B ?? ""}">
                      <input class="ibox" inputmode="numeric" pattern="[0-9]*" maxlength="2" data-mid="${esc(mid)}" data-k="s3B" value="${v.s3B ?? ""}">
                    </div>
                  </div>
                </div>

                <button class="btnsave" data-act="save" data-mid="${esc(mid)}">
                  ${done ? "‚úÖ Mettre √† jour" : "üíæ Enregistrer / Valider"}
                </button>

                <div class="muted-mini">
                  <span style="font-weight:900;">Derni√®re maj :</span>
                  ${stored.updatedAt?.toDate ? esc(stored.updatedAt.toDate().toLocaleString()) : "‚Äî"}
                </div>
              </div>
            </div>
          </div>
        </div>
      `);
    }

    matchCards.innerHTML = cards.join("") || `<div class="muted">Aucun match.</div>`;
    statusText.textContent = "‚úÖ OK (modif possible m√™me apr√®s validation).";
  }

  function readInputsFor(mid){
    const get = (k)=>{
      const el = document.querySelector(`input[data-mid="${CSS.escape(mid)}"][data-k="${CSS.escape(k)}"]`);
      return el ? el.value : "";
    };

    // raw -> int/null
    const raw = {
      s1A: toIntOrNull(get("s1A")),
      s1B: toIntOrNull(get("s1B")),
      s2A: toIntOrNull(get("s2A")),
      s2B: toIntOrNull(get("s2B")),
      s3A: toIntOrNull(get("s3A")),
      s3B: toIntOrNull(get("s3B")),
    };

    return raw;
  }

  function showErr(mid, msgs){
    const el = document.getElementById(`err-${mid}`);
    if(!el) return;
    if(!msgs || msgs.length === 0){
      el.style.display = "none";
      el.textContent = "";
      return;
    }
    el.style.display = "block";
    el.textContent = "‚ùå " + msgs.join(" ‚Äî ");
  }

  async function saveResult(mid){
    const raw = readInputsFor(mid);
    const out = computeOutcome(raw);

    if(!out.ok){
      showErr(mid, out.errs);
      return;
    }
    showErr(mid, []);

    const userEmail = auth.currentUser?.email || null;

    // Store: sets/games/tb + score lines + winnerSide
    const payload = {
      matchId: mid,
      // raw sets
      s1A: out.s1A, s1B: out.s1B,
      s2A: out.s2A, s2B: out.s2B,
      s3A: out.needTB ? out.s3A : null,
      s3B: out.needTB ? out.s3B : null,

      // computed
      setsA: out.setsA,
      setsB: out.setsB,
      gamesA: out.gamesA,
      gamesB: out.gamesB,
      tbA: out.tbA,
      tbB: out.tbB,

      winnerSide: out.winnerSide, // null tant que pas complet
      scoreA: out.scoreA,
      scoreB: out.scoreB,
      score: out.score,

      updatedAt: serverTimestamp(),
      validatedBy: userEmail
    };

    await setDoc(doc(db, `resultats_${currentScope}`, mid), payload, { merge:true });
  }

  function startProgListener(scope){
    if(unsubProg){ unsubProg(); unsubProg = null; }

    unsubProg = onSnapshot(progRef(scope), (snap)=>{
      currentProg = snap.exists() ? (snap.data() || {}) : null;
      renderAll();
    }, (err)=>{
      console.error(err);
      statusText.textContent = "üî¥ Erreur programmation.";
    });
  }

  function startResultsListener(scope){
    if(unsubRes){ unsubRes(); unsubRes = null; }

    unsubRes = onSnapshot(resultsCol(scope), (snap)=>{
      resultsByMatch = new Map();
      snap.forEach(d=>{
        resultsByMatch.set(d.id, d.data() || {});
      });
      renderAll();
    });
  }

  // ---- UI (scope)
  function showDenied(){
    accessDenied.style.display = "block";
    adminUI.style.display = "none";
    panelNeedStep.style.display = "none";
    panelResults.style.display = "none";
    stopListeners();
  }

  function showAdmin(){
    accessDenied.style.display = "none";
    adminUI.style.display = "block";

    scopeEl.value = currentScope;
    setTabs(currentScope);
    showPanelsForScope(currentScope);

    scopeEl.onchange = ()=>{
      currentScope = scopeEl.value || "general";
      setTabs(currentScope);
      showPanelsForScope(currentScope);
    };
  }

  // ---- Events
  btnOpenPublic.onclick = (e)=>{
    e.preventDefault();
    if(currentScope === "general"){ alert("Choisis une √©tape."); return; }
    window.location.href = `../${currentScope}/programmation.html`;
  };

  matchCards.addEventListener("click", async (e)=>{
    const btn = e.target.closest("button[data-act='save']");
    if(!btn) return;

    const mid = btn.dataset.mid;
    if(!mid) return;

    btn.disabled = true;
    try{
      await saveResult(mid);
    }catch(err){
      console.error(err);
      alert("Erreur Firestore ‚ùå");
    }finally{
      btn.disabled = false;
    }
  });

  // Logout
  document.getElementById("btnLogout").onclick = async (e)=>{
    e.preventDefault();
    await logout();
    window.location.href = "../index.html";
  };

  // Guard
  const g = await requireRole(["admin"]);
  if(!g.ok){ showDenied(); }
  else { showAdmin(); }

  onAuthStateChanged(auth, async (user)=>{
    if(!user){ showDenied(); return; }
    const g2 = await requireRole(["admin"]);
    if(!g2.ok){ showDenied(); return; }
  });
</script>

</body>
</html>
